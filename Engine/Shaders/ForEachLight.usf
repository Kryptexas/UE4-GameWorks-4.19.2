// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	ForEachLight.usf: Common code for dynamic forward lighting
=============================================================================*/

#ifndef __FOR_EACH_LIGHT_COMMON__
#define __FOR_EACH_LIGHT_COMMON__

#include "DeferredLightingCommon.usf"	// FSimpleDeferredLightData and GetSimpleDynamicLighting() 
Buffer<uint> LightGrid;

float3 SimplePointLightDiffuse( FScreenSpaceData ScreenSpaceData )
{
	return Diffuse_Lambert(ScreenSpaceData.GBuffer.DiffuseColor);
}

float3 LightingForOneLight(FMaterialPixelParameters Parameters, FSimpleDeferredLightData LightData, FScreenSpaceData ScreenSpaceData)
{
	float3 CameraVector = normalize(Parameters.WorldPosition - View.ViewOrigin.xyz);

	// At the moment we only support very simple lighting (no shadows, phong, no area lights, basic attenuation).
	// Later we can extend this function.

	float3 Surface = GetSimpleDynamicLighting(Parameters.WorldPosition, CameraVector, ScreenSpaceData, LightData);
	// todo: investigate why this doesn't work
//	float3 Surface = GetSimpleDynamicLighting(Parameters.WorldPosition, Parameters.CameraVector, ScreenSpaceData, LightData);

	// todo: cleanup (share with former code)

	// assuming inverse square falloff

	half Opacity = GetMaterialOpacity(Parameters);
	float3 ToLight = LightData.LightPositionAndInvRadius.xyz - Parameters.WorldPosition;

	// Sphere falloff (technically just 1/d2 but this avoids inf)
	float DistanceSqr = dot( ToLight, ToLight );
	float DistanceAttenuation = 1 / ( DistanceSqr + 1 );
	
	float LightRadiusMask = Square( saturate( 1 - Square( DistanceSqr * Square(LightData.LightPositionAndInvRadius.w) ) ) );

	float SubsurfaceAttenuation	= DistanceAttenuation * LightRadiusMask;

	float3 Subsurface = (1 - Opacity) * LightData.LightColorAndFalloffExponent.rgb * SubsurfaceAttenuation
		* TwoSidedFoliageShadingSubsurface(ScreenSpaceData.GBuffer.DiffuseColor, normalize(ToLight), -CameraVector, ScreenSpaceData.GBuffer.WorldNormal);


	return Subsurface + Surface;

}

// @param WorldNormal is not assumed to be normalized
float3 AccumulateForwardLights(FMaterialPixelParameters Parameters, float3 DiffuseColor, float Roughness, float3 SpecularColor)
{
	float3 Ret = 0;

	// not yet supported on opengl (firstbitlow() does not exist)
#if !COMPILER_GLSL && !COMPILER_GLSL_ES2

	// Which tile we are?
	int2 Tile = int2((Parameters.SVPosition.xy - View.ViewRectMin.xy) * ForwardLightData.InvTileSize);

	// Get bitmask from CPU for this tile
	uint culling = LightGrid[Tile.x + Tile.y * ForwardLightData.TileCountX];

	FScreenSpaceData ScreenSpaceData = (FScreenSpaceData)0;
	ScreenSpaceData.GBuffer.WorldNormal = normalize(Parameters.WorldNormal);
	ScreenSpaceData.GBuffer.Roughness = Roughness;
	ScreenSpaceData.GBuffer.SpecularColor = SpecularColor;
	ScreenSpaceData.GBuffer.DiffuseColor = DiffuseColor;
	ScreenSpaceData.AmbientOcclusion = 1;

	// todo: support more than 32 lights

	// loop through all lights specified by this bitmask
	ALLOW_UAV_CONDITION while (culling != 0)
	{
		uint LightIndex = firstbitlow(culling);

		culling &= ~(1 << LightIndex);

		FSimpleDeferredLightData LightData = (FSimpleDeferredLightData)0;
		LightData.LightPositionAndInvRadius = ForwardLightData.LightPositionAndInvRadius[LightIndex];
		LightData.LightColorAndFalloffExponent = ForwardLightData.LightColorAndFalloffExponent[LightIndex];
		LightData.bInverseSquared = true;

		Ret += LightingForOneLight(Parameters, LightData, ScreenSpaceData);
	}
#endif

	return Ret;
}

#endif // __FOR_EACH_LIGHT_COMMON__