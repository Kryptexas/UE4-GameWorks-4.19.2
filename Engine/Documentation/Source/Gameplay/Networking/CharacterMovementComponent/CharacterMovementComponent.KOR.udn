INTSourceChangelist:2607939
Availability:Public
Title: 캐릭터 무브먼트 컴포넌트
Crumbs:%ROOT%, Gameplay, Gameplay/Networking, Gameplay/Networking/Actors
Description:Character Movement Component, 캐릭터 무브먼트 컴포넌트에 대한 상세 설명입니다.
Related: Gameplay/Networking/Actors

[TOC (start:2 end:3)]

CharacterMovementComponent 를 사용하는 캐릭터는 자동으로 클라이언트-서버 네트워킹이 탑재됩니다. CharacterMovementComponent 를 통한 네트워크 게임에서의 플레이어 이동 예측, 리플리케이션, 보정 작동 방식은 이렇습니다:
	
매 틱마다 TickComponent() 함수가 호출됩니다. 프레임에 대한 가속도 및 회전 변경을 알아낸 다음, (로컬 제어 캐릭터의 경우) PerformMovement() 또는 (네트워크 클라이언트의 경우) ReplicateMoveToServer() 를 호출합니다.
	
ReplicateMoveToServer() 는 (PendingMove 목록에) 이동을 저장하고 PerformMovement() 를 호출한 뒤, 리플리케이트되는 함수 ServerMove() 에 무브먼트 파라미터, 클라이언트의 결과 위치, 타임스탬프를 전달하여 호출하는 것으로 이동을 서버에 리플리케이트합니다.
	
ServerMove() 는 서버에서 실행됩니다. 무브먼트 파라미터를 디코딩한 다음 적합한 이동이 발생하도록 만듭니다. 그런 다음 결과 위치를 살펴보고, 지난 번 반응 이후 시간이 너무 많이 흘렀거나, 위치상의 오차가 심각한 경우, 서버는 리플리케이트되는 함수 ClientAdjustPosition() 을 호출합니다.
	
ClientAdjustPosition() 가 클라이언트에서 실행됩니다. 클라이언트는 그 위치를 서버 버전 위치로 설정하고, bUpdatePosition 플래그를 true 로 설정합니다.
	
클라이언트에서 TickComponent() 가 다시 호출되고 bUpdatePosition 가 true 인 경우, 클라이언트는 PerformMovement() 호출 전 ClientUpdatePosition() 을 호출합니다. ClientUpdatePosition() 는 서버가 이동을 조절했을 당시 타임스탬프 이후 발생한 이동 대기 목록의 이동을 전부 재생합니다.

##캐릭터 무브먼트 및 시뮬레이티드 프록시

지금까지 설명한 CharacterMovementComponent 의 접근법은 권위적 서버에 접속된 클라이언트 하나에 대해서만 자세히 다루고 있습니다. 그러면 서버에서 이동하는 AI 라든가 다른 컴퓨터에서 플레이하는 다른 플레이어는 어떨까요? 클라이언트 머신에서 그러한 것들은 모두 시뮬레이티드 프록시로 간주되며, 약간 다른 코드 패쓰를 통합니다.

사람이 제어하지 않는 캐릭터의 이동은 보통 일반적은 PerformMovement() 코드를 사용하여 (오쏘리티가 있는) 서버에서 업데이트됩니다. 위치, 회전, 속도와 같은 액터 상태는 물론 기타 캐릭터 전용 (점프 등) 상태도 일반 리플리케이션 메커니즘을 통해 다른 머신으로 리플리케이트됩니다. 매 프레임 네트워크까지 내려올 필요가 없다는 뜻입니다. 원격 클라이언트에서 해당 캐릭터가 더욱 부드러워 보이게 하기 위해서, 클라이언트 머신은 새로운 (서버 오쏘리티가 있는) 데이터가 도착할 때까지 시뮬레이티드 프록시에 대해 매 프레임 시뮬레이션 업데이트를 실행합니다. 다른 원격 사람 플레이어를 로컬 클라이언트에서 볼 때도 마찬가지입니다. 그 원격 플레이어는 서버에 업데이트 정보를 보내고, 거기서 그 플레이어에 대한 무브먼트 업데이트가 완벽히 이루어진 다음, 주기적으로 그 데이터를 다른 모든 플레이어에게 리플리케이트합니다.

이 업데이트의 의도는 리플리케이션 상태에 따라 무브먼트 결과 측정치를 시뮬레이션하여 다음 업데이트시까지의 "간극을 메우기" 위한 것입니다. 즉 서버에서 전송된 새 위치에 프록시를 배치하여 (앞으로 몇 프레임 후가 될 수도 있는) 다음 업데이트가 도착할 때까지 거기 가만히 놔두기 보다, 클라이언트는 속도와 이동 규칙을 적용하여 매 프레임 위치를 시뮬레이션하여 업데이트하는 것입니다. 다른 업데이트가 도착하면, 실제적으로 로컬 시뮬레이션을 리셋시킨 다음 새로 시작시킵니다.

시뮬레이티드 프록시에 대한 대량 무브먼트 업데이트는 UCharacterMovementComponent::SimulateMovement() 에서, 그 이후 MoveSmooth() 에서 차례로 이루어집니다. MoveSmooth() 는 일반적으로 다양한 (보행, 비행 등의) 이동 모드에 대한 풀버전 이동 모드 업데이트를 간소화시킨 버전으로, 실행 비용도 싸고 의도상 복잡도도 덜합니다.

###시뮬레이티드 프록시 스무딩

캐릭터가 단순히 전방 이동하는 경우, 시뮬레이션된 업데이트는 다음 리플리케이션 업데이트에 매우 근접할 확률이 높습니다. 직선 운동은 예측이 꽤나 간단하기 때문입니다. 월드에 고정된 벽에 달려가는 경우에도, 그 편차나 잇따른 업데이트 역시 높은 정확도로 시뮬레이션 가능할 것입니다.

하지만 기존 리플리케이트된 상태의 스냅샷 기반 로컬 시뮬레이션이 실제 올바른 위치에서 벗어나게 되는 경우가 몇 가지 있습니다. 시간 t=0 에 (100,0,0) 의 속도로 이동하는 캐릭터의 리플리케이트된 상태를 가정해 봅시다. t=1 에서의 1 초 후 업데이트에서, 시뮬레이티드 프록시는 X 방향으로 100 유닛 이동했을 것입니다. 하지만 서버에서의 실제 이동은 (100,0,0) 속도 업데이트를 보낸 즉시 이동을 멈췄다면, 다음 번 리플리케이션에서는 서버 버전의 프록시 위치가 로컬에서 시뮬레이션한 위치와 다를 것입니다.

서버 업데이트를 받았을 때 시뮬레이티드 프록시의 위치가 시각적으로 "튀어" 보이는 것을 방지하기 위해, UCharacterMovementComponent::SmoothClientPosition() 함수를 사용하여 캐릭터의 메시 (콜리전 표현에 사용되는 단순한 모양이 아닌 바디의 복잡한 시각적 표현) 위치에 스무딩 작업을 해 줍니다. 이는 기본적으로 (클라이언트의 네트워크 데이터 상의 "SmoothNetUpdateTime" 으로 설정된) 특정 기간 내 대상 위치에 도달하도록 하는 단순한 스무딩을 적용하는 것입니다.

##CharacterMovementComponent 네트워킹 디버깅

캐릭터 네트워킹의 디버깅 및 분석을 위한 유용한 툴이 몇 가지 있습니다. 무언가 잘못되어 보이는 클라이언트의 콘솔에서 보통 먼저 해 보면 좋은 것은, "p.NetShowCorrections 1" 를 입력하는 것입니다 (Shipping 빌드가 아닌 경우에만 작동합니다). 이 옵션을 서버에서 켜는 것도 좋을 수 있습니다. 이를 통해 출력 콘솔의 로그는 물론 콜리전 모양의 (초록색) "올바른" 위치 및 (빨강색) "잘못된" 위치를 그려주는 것으로 클라이언트에서 수신된 (또는 서버에서 전송된) 네트워크 보정 정보를 확인할 수 있습니다. 클라이언트에서 "올바른" 위치는 서버에서 보정을 위해 전송된 것인 반면, "잘못된" 위치는 서버에서 오차 허용 범위를 벗어난 것으로 판단된 로컬 위치입니다. 서버에서도 그 개념은 비슷합니다. "올바른" 서버 위치는 초록색으로 그려지는 반면, "잘못된" 클라이언트 수신 위치는 빨강으로 그려집니다. "p.NetCorrectionLifetime" 는 월드에서 디버그 시각화가 사라지기 전까지 유지되는 기간을 초 단위로 나타냅니다 (예를 들어 "p.NetCorrectionLifetime 5" 는 5 초간 유지됩니다).

문제 진단에 도움이 되는 또 한가지 방법은, CharacterMovement 네트워크 무브먼트 함수에 의해 전송된 데이터 일부의 로그를 켜는 것입니다. "log LogNetPlayerMovement Verbose" 콘솔 명령으로 위치, 회전, 가속도를 포함한 캐릭터 무브먼트 데이터의 송수신 내역 각각에 대한 로그를 켭니다. 위치 변화가 서버에 리플리케이트되지 않는 방식으로 클라이언트에서 이루어져 발생한 오차 보정에 대한 설명이 될 수 있습니다.

##고급 토픽: 캐릭터 무브먼트에 새로운 무브먼트 능력 추가하기

캐릭터에 새로운 무브먼트 능력을 추가할 때, 그 방법은 여러가지 있습니다. 네트워크 게임에서 통하는 "텔레포트" 능력을 캐릭터에 추가해 보기 위한 이론적 시도를 살펴보도록 합시다. 기본적인 개념은 플레이어가 "T" 키를 누르면, 전방 10 미터에 장애물이 없는 경우 그 위치로 텔레포트하는 것입니다.

###접근법 1: 클라이언트에서만 실행
이 접근법에서는 네트워킹에 대해 전혀 고려하지 않고 그냥 T 를 누르면 전방 텔레포트를 시전합니다.

**결과**: 네트워크 게임에서 실패합니다. 로컬 클라이언트에서는 잠깐 텔레포트한 것으로 보였다가 시작 위치로 빠르게 되돌아옵니다.

**분석**: 네트워킹에 대해 어떤 작업도 하지 않은 기본적인 경우로, 실패하게 마련입니다. 왜냐고요? 서버에서는 그 능력이 발동되었다고 알려진 바도 없고, 그냥 클라이언트의 캐릭터 이동 관련해서 위치, 회전, 가속도 작업을 한 것이니, 캐릭터가 그렇게 앞으로 이동했다는 것이 이치에 맞지 않습니다.

###접근법 2: 서버만 RPC
네트워크 상태에서 작동하도록 만드는 가장 간단한 접근법은, 능력을 발동시키는 신뢰성 네트워크 RPC 를 구성하는 것입니다. 이 경우 그냥 텔레포트를 하는 서버 함수를 호출합니다.

**결과**: 네트워크 게임에서 작동은 하지만, 클라이언트 측에서 눈에 띌만큼의 지연이 생긴다든가 일부 텔레포트 함수성의 손실 가능성이 있다든가 하는 주요 문제점이 있을 수 있습니다.

**분석**: 작동은 하지만, 이상적이지는 않습니다. 이벤트를 순서대로 보면 이렇습니다: 서버는 플레이어를 전방으로 텔레포트하는 함수 호출을 받습니다. 클라이언트에서의 캐릭터 무브먼트 업데이트는 텔레포트되지 않은 위치로 서버에 전송됩니다. 서버는 이를 오차로 판단하는데, 서버 버전은 RPC 를 통해 텔레포트되었기 때문입니다. 서버는 클라이언트에 보정 정보를 전송하고, 클라이언트 위치는 텔레포트된 것으로 변경됩니다. (디버깅 팁: 여기서 "p.NetShowCorrections 1" 명령을 사용하면 도움이 되는데, 무브먼트가 네트워크 보정의 결과라는 것을 확인할 수 있기 때문입니다.)

여기에는 문제가 많습니다: 네트워크 랙이 있는 경우, 클라이언트는 서버까지 왕복하는 시간동안 기다린 이후에나 로컬 머신에서 텔레포트가 실제로 일어납니다. 플레이어에게 안좋은 느낌을 줍니다. 게다가 "텔레포트" 능력에 발생하는 부가적인 함수성이 클라이언트측에서 전혀 발동되지 않을 수 있습니다. 절대로 로컬에서 그 능력이 실제 실행되지는 않기 때문입니다. 즉 예를 들어 목적지에서 사운드 및 파티클 이펙트를 재생한 경우, 클라이언트에서는 손실될 것입니다.

###접근법 3: 서버 RPC 및 로컬 트리거
이 접근법에서, 클라이언트는 텔레포트를 실행한 뒤 텔레포트 실행을 위한 서버 RPC 도 호출합니다.

**결과**: 네트워크 게임에서 작동은 하며, 희박하지만 심각한 문제가 있을 수 있습니다.

**분석**: 이 접근법은 기존 접근법의 단점, 말하자면 로컬에서의 이동 지연과, 이동이 능력으로 인한 것이 아닌 보정으로 인해 발생했다는 사실을 보완하기 위한 것입니다. 사운드나 파티클 이펙트같은 텔레포트의 함수성도 전부 얻을 수 있습니다. 사실 꽤나 잘 돌아갑니다만, 중요한 점 한 가지가 빠져 있어 네트워크 환경에서는 깨질 수가 있습니다.

주요 문제점은 클라이언트가 텔레포트 발동 시점 이전으로 보정된 경우, 현재 시간으로 따라잡으면서 텔레포트를 재발동시킬지 여부를 알 수가 없어, 클라이언트측에서 텔레포트가 손실된 것으로 보인다는 점입니다.

###접근법 4: CharacterMovementComponent 능력 구현
이 접근법에서는 CharacterMovementComponent 코드(의 자손 클래스)에 텔레포트 능력에 대한 지식을 추가하여, 네트워크 보정에 대해 강화시킵니다.

**결과**: 네트워크 게임에서 작동하며, 구현시 몇 가지 주의하기만 하면 됩니다.

**분석**: 여기에는 약간의 배경지식이 필요합니다: 앞서 언급했듯이, CharacterMovementComponent 를 사용하는 캐릭터는 "저장된 이동 목록" 또는 "대기중인 이동 목록" 같은 것에 입력 결과를 큐 형태로 저장합니다 (C++ 코드에서 이러한 이동은 "FSavedMove_Character" 클래스에서 파생됩니다). 저장된 이동 각각은 한 프레임에서 이동 시작시의 상태, 이를테면 (보통 플레이어 입력의 결과인) 위치, 회전, 가속도, 점프 상태 등을 기록합니다.

이동이 클라이언트에서 서버로 전송되면서, 그 이동을 유지하다가 서버에서의 승인이 떨어지면 예전 것들을 제거합니다 (서버에서 보는 우리 위치는 지금 우리가 보는 것에 약간 뒤쳐져 있다는 점 기억하세요). 보정의 경우, 그게 언제 발생했는지 알고 있고, 해당 시점 이후 발생한 모든 이동을 "다시 재생"할 수 있습니다. 이것이 좋은 점은, 클라이언트에서는 보정 시점 이후로 제때 맞춰 전방 이동 시도할 것이므로, 보정이 있었는지 알지도 못한다는 점입니다. 보정 이후 발동된 능력이 다시 재생된다는 뜻이기도 합니다. 능력에서 이러한 경우에 대한 검사를 하여, 일부 이펙트가 재발동된 경우 다시 발동시키지 않도록 할 수 있습니다 (예제로 UCharacterMovementComponent::DoJump() 함수의 "bReplayingMoves" 파라미터를 참고하세요).

"텔레포트" 능력 추가로 다시 돌아가 봅시다! CharacterMovementComponent 에서 점프를 처리하는 방식과 이미 매우 유사하게 처리됩니다. 그저 이 능력이 발동되었음을 알리고, 서버에서 제대로 처리해 주기만 하면 되는 것입니다. 물론 클라이언트의 빠른 반응을 위해 로컬에서도 실행해 줘야 합니다. 클라이언트와 서버 사이의 데이터 송수신은 기존 네트워킹의 일환으로 자동 수행되니, 데이터의 패킹 및 언패킹만 해 주면 됩니다.

우선 UCharacterMovementComponent 클래스를 파생한 다음 AllocateNewMove() 를 덮어써서 FSavedMove_Character 자체 버전을 만들어 줘야 합니다. 이 시점에서 FSavedMove_Character 에 메소드를 몇 가지 구현해 줘야 하는데, 가장 중요한 것은 GetCompressedFlags() 로, 텔레포트 능력을 발동시켰다 알리는 데이터 비트를 패킹해 넣는 것입니다. 그런 다음 UCharacterMovementComponent::UpdateFromCompressedFlags() 를 덮어쓰는데, 그 플래그 언패킹 및 서버측에서 그 능력이 발동되었음을 처리하는 것입니다.

거의 다 됐습니다. CharacterMovementComponent 이동 저장 방식에 커스텀 플래그를 구현하는 데 있어 조금 더 복잡해 질 가능성은 얼마든지 있을 수 있지만, 이 정도면 제대로 시작하는 데 충분할 것입니다. 네트워크에서도 확실한 이동 처리를 원한다면, 노력을 들일 만한 가치가 있습니다.
