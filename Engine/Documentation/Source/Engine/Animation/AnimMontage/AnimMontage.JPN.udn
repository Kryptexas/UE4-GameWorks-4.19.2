INTSourceChangelist:3429233
Availability:Public
Title:AnimMontage
Crumbs:
Description:AnimMontage の詳細と UE4 のアニメーションシステムにおけるその活用法
Related:Engine/Content/FBX/Animations
Related:Engine/Content/Types/SkeletalMeshes
Related:Engine/Animation/PhysicallyDrivenAnimation
Related:Engine/Animation/StateMachines
Related:Gameplay/AI
Related:Engine/Content/Tools/MayaRiggingTool
Related:Engine/Animation/RootMotion
Related:Gameplay/Input
version:4.14
Parent:Engine/Animation
Order:
tags:Animation Montage
tags:Animation
type:overview
tags:Assets
topic-image:Engine/Animation/Overview/MontageTopic.png

[TOC(start:2 end:3)]

[EXCERPT:Intro]
**AnimMontage** (アニム モンタージュまたは略してモンタージュ) は、幅広いアニメーション エフェクトを有効にする多目的ツールです。主にコードや [ブループリント ビジュアル スクリプティング](Engine/Blueprints) 内部のアニメーション制御の公開に関わっています。インテリジェントなアニメーションのループ、ロジックベースのアニメーションの切り替えなど、多岐に渡るアニメーション エフェクトも作成します。
[/EXCERPT:Intro]

AnimMontage は、**コンテンツ ブラウザ** で作成され、このブラウザに存在するアニメーション アセットです。これらのアセットは実行中に AnimGraph へ直接プラグインし、そのステートを編集することができます。例えば、別のセクションへジャンプしたり、別のセクションに再度リンク付けができます。主にコードで操作するメレー攻撃などのアニメーション (または 1 回限りのアニメーション用) で、トリガーの制御、好きな時に停止、 (ループか非ループ) のステートの変更が可能になります。 

アニメーションでルート モーションが有効になっていれば、AnimMontage はゲームをネットワーク間で複製する手段を提供します。 

##AnimMontage のサンプル

![](Montage_Screen2.png)

上の画像は  _Start_, _Loop_, および _End_ の 3 セクションによるメレー攻撃です。セクション間の区切りは、黄色で示されています。プレイヤーが攻撃ボタンを押すと、ゲームによってアニメーションが再生されて  _Start_ セクションから開始します。_Loop_ (ループに設定) という真ん中のセクションは、_Start_ セクションの直後に続き、そこで永続的にループします。プレイヤーが攻撃ボタンを解放すると、アニメーションのループは停止し、最終的に _End_ セクションに到達し、遷移します。

他にも以下のような使用方法があります。
* AnimBlueprint の **EventGraph** からアニメーションを再生する機能
* 単一アニメーションとして考えたい複雑なアニメーション シーケンスをつなげる
* アニメーションの特定部分のみ、またはコードやブループリント スクリプトに基づいたアニメーションのループ
* コードやブループリント スクリプトに基づいた複数アニメーションのイベントベース切り替えによる処理
* コードやブループリントで切り替え可能な指定スロットへ複雑なアニメーションシーケンスを割り当てる機能
* コードやブループリント スクリプトに基づいたさまざまなアニムシーケンス間の正確な切り替え

[REGION:note]
キャラクターに AnimMontage を適用した例は [アニメーションのコンテンツ サンプル](Resources\ContentExamples\Animation) ページでも紹介しています。
[/REGION]

##AnimMontage のプロパティ

以下は AnimMontage アセット プロパティの内訳です。モンタージュを見ている時に、これらのプロパティを利用することができます。**コンテンツ ブラウザ** 内でモンタージュを右クリックして、コンテキストメニューから [Properties] を選択してアクセスすることもできます。

![](MontageProperties.png)

|モンタージュのプロパティ||
|---|---|
|[REGION:tablesection]モンタージュ[/REGION]||
|**Blend In Time**|モンタージュの再生開始の時間の長さです。キャラクターはこの間に現在のポーズからブレンドインします。|
|**Blend Out Time**|モンタージュ再生終了の時間の長さです。キャラクターはこの間にオリジナルのポーズに再びブレンドします。|
|**Blend Out Trigger Time**| Sequence End からブレンドアウトのトリガーまでの時間。 < 0 は BlendOutTime を使用するため、BlendOut は Montage が終わるに従い終了します。 > = 0 は、SequenceEnd-BlendOutTriggerTime を使用してブレンドアウトをトリガーします。 |
|[REGION:tablesection]追加設定[/REGION]||
|**Preview Base Pose**|加算ブレンドスペースで使用するベースのプレビューポーズを設定します。|
|[REGION:tablesection]Animation[/REGION]||
|**Rate Scale**| モンタージュの再生の速度を示す乗数値です。デフォルトは値 1.0 です。|
**Skeleton**|モンタージュと関連したスケルトンを格納します。エディタで変更はできません。|
|[REGION:tablesection]メタデータ[/REGION]||
|**Meta Data**| アセットと共に保存可能なメタデータです。このメタデータは Anim Meta Data クラスから派生したブループリントで利用可能なクラスです。カスタムのメタデータを Animation アセットに追加できます (Anim Sequence、 Anim Montage、 Anim Composite、 および Blendspace はすべてサポートされます)。C++ で Animation アセットからこうしたデータをクエリーできます。`GetMetaData()` メソッドを呼び出すか、Anim Montages で `GetSectionMetaData()` を使用します。
|[REGION:tablesection]サムネイル[/REGION]||
| **Orbit Pitch** | アセット周囲の軌道カメラのピッチです。 |
| **Orbit Yaw** | アセット周囲の軌道カメラのヨー (左右回転) です。 |
| **Orbit Zoom** | アセットから境界の球体の距離のオフセットです。 |

##モンタージュの UI

モンタージュを見る時に、各領域とその役割を知っておくと便利です。

[REGION:raw]
![](MontageUI.png)
[/REGION]

1. [Montage 領域](#Montage領域)
1. [Sections 領域](#Sections領域)
1. [Element Timing 領域](#elementtiming領域)
1. [Notifies 領域](#Notifies領域)
1. [Curves 領域](#Curves領域)

##Montage 領域

モンタージュの領域は以下のように分類できます。

[REGION:raw]
![](MontageArea.png)
[/REGION]

1. **セクション トラック** - このモンタージュのために定義された [セクション](#セクション) を表示します。セクションはタイムラインと一緒に、左マウスボタンで別の位置へドラッグできます。
1. **スロット トラック** - 右側にスロット名を表示した現在の [スロット](#スロット) を表示します。スロットは必要に応じたアニメーション数で埋めることができます。アニメーションは順番に再生されます。複数のアニメーションが、上、下、そして再度上などの [Slot Track] で交互に行われていることに留意してください。異なるアニメーション間でそれぞれのアニメーションを識別する際に役立ちます。

[REGION:note]
単一モンタージュ内に必要な数だけ Slot Track を持つことができます。各スロット トラックには独自の名前があり、独自の固有アニメーションがあります。ただし、各モンタージュには、**セクション トラック** が 1 つずつだけ存在する場合もあります。
[/REGION]

### セクション

モンタージュ セクションは、スロットを複数部分のアニメーションへ分割します。各セクションは、スロットのタイムラインに名前と位置が設定されています。現在のセグメントの終了時に、名前を使用して特定のセクションへ直接ジャンプしたり、次に再生させるためにキューに入れることができます。ブループリントでは、現在のセクションのクエリ、セクションへジャンプ、再生する次のセクションを設定することができます。

セクションをミュージック プレイリストの歌、スロットをアルバムと考えるとわかりやすいかもしれません。最近の多くのメディアプレイヤー同様に、再生中の曲の終了時に次に再生する曲を選択したり、今すぐ聞きたい曲に単にジャンプすることができます。

セクションは、セクション トラックを 右クリック して、 **[New Montage Section]** を選択して作成します。 


### スロット

[EXCERPT:Slots]
モンタージュ内では、 **スロット** は任意の数のアニメーションを保持することができる単一トラックです。スロットに任意の名前を付けて、その名前を使って特定のアニメーションにブレンドすることができます。よい例として武器をリロードしたアニメーション キャラクターがあります。キャラクターが直立している時、かがんでいる時、うつ伏せ時に異なるリロード バージョンが必要かもしれません。3 つ全てのアニメーションを同じタイミングで使用すれば、各アニメーションをモンタージュの別個のスロット内に配置することができます。スロットには、Standing 、 Crouching、Prone と名前を付けます。Animation ブループリントの **AnimGraph** で、現在のキャラクターのステートに基づいて次に再生するものを決めるために、Slot ノードを使用することができます。キャラクターが立っている時、アニメーションの結果を Standing スロットで使用します。キャラクターがうつ伏せになっている時は、Prone スロットの結果を確認できます。

ほとんどのモンタージュ制御は Animation ブループリントの **イベントグラフ** で行われますが、スロットは実のところ **Anim Graph** で処理されていることを覚えておくのは大変重要です。これは、スロットの名前を受け取る Slot ノードを経由して実行します。AnimGraph の実行と一緒にこのノードを戦略上のポイントとして位置づけることにより、同じスロット名を利用する複数のモンタージュを保持することができます。
[/EXCERPT:Slots]

<!---------------- Branch moved to Notify page.
###Branch Point （分岐点）

分岐点はアニメーション再生と一致するイベントを作成します。Branch Point Event は、別の現象を発生させるためにコードまたはブループリントで使用しますが、特にモンタージュ内で別のアニメーションセクションへの切り替えに便利です。 

既に [アニメーション通知](Engine/Animation/Sequences\Notifies) に精通しているユーザーは、スクリプトで活用するイベントを公開するという点で、両システムには顕著な類似性があることにお気づきかもしれません。アニメーション通知は非同期、分岐点は同期である点が大きな違いです。エンド ユーザーにとって、分岐点は、アニメーション タイムラインに沿って実行される時により高度な正確性を持つことを意味します。

正確なタイミングに合わせて特定のアニメーションへジャンプしなくてはいけない時、高精度であることは重要です。通知を使用して同じジョブを実行することも可能ですがが、Notify Event が間違ったアニメーション フレームで発行される場合もある通知の非同期的な性質が、モーションの処理落ちやジャンプの原因となることがあります。

[REGION:warning]
分岐点がもつ同期性質と最終的な高度な正確性により、Branch Point は通知よりもよりパフォーマンス負荷がかかります。フレーム間で一致するもうひとつのアニメーションへ直接ジャンプさせるなど、イベントをアニメーション タイムラインに沿って正確なタイミングで発行させなければいけない時のみ分岐点を使用してください。フレームでずれてしまう (何らかの比率で) ことが重要でない場合は、代わりに通知を使用してください。
[/REGION]

-------------------->

## Sections 領域

セクション領域で、モンタージュ領域で定義したセクション間の関係を確立します。例えば、アニメーションの特定セクションやセクションのグループを、ある特定のシーケンスやループなどで再生します。 

[REGION:raw]
![](SectionsArea.png)
[/REGION]


1. **[Create Default (デフォルトを作成)] ボタンと [Clear (クリア)] ボタン** - **[Create Default]** は、セクションを交互に並べて、全セクション間のデフォルトの関連性を作成します。**[Clear]** は関連性を全てクリアします。
1. **[Section] ボタン** - モンタージュ領域で定義した各セクションに対応するボタンが表示されます。既存のセクションを選択してボタンの 1 つをクリックすると、ボタンと対応するセクションと選択したトラックを関連付けます。例えば上の画像は、Swing2 を Swing1 と関連付けました。実際の順番は、Swing1、Swing2、そして再びループを発生させる Swing1 となります。詳細は、以下の [ループ](#ループ) セクションを参照してください。 
1. **セクション関連付けトラック** - アニメーション セクション間を可視化およびプレビューする領域です。**[Preview]** ボタンをクリックすると、各トラックの結果が表示されます。または、 **[Preview All Sections (全セクションをプレビュー)]** ボタンをクリックすると、全セクションが順番に再生されます。

### ループ

セクションは無制限にループを設定することができます。繰り返しが必要なアクションなどには非常に便利です。Section Association Track で同じセクションを複数回以上関連付けることにより、この関連付けをループで実行することができます。この時、セクションは青色に変わります。例えば、一度に 1 つの砲弾をショットガンにリロードするキャラクターのアニメーションを作成すると仮定します。キャラクターが砲弾を挿入するセクションのみを取り込んで、これをループさせます。それから通知を利用して、アニメーションが再生されるごとに弾薬カウントをインクリメントするように、ブループリントで Notify Event を作成します。カウントが設定数に達したら (銃弾の許容量)、キャラクターがレシーバーをクローズするアニメーションに切り替えて、アイドル ステートに戻ります。

## Element Timing 領域

Element Timing 領域 は、様々なセクションのタイミングと合わせるために Montage 領域と Notifies 領域からの情報を受け取ります。

![](ElementTiming1.png)

トラックの各ノードにはそのオブジェクトのモンタージュ全体でのトリガー順序を表す数字が与えられています。また、以下の説明に合わせて色分けされています。デフォルトの色は以下の通りです。
* 赤 - 通知、通知ステート、通知ステートの終了マーカー
* 水色 - 分岐点の通知
* 緑- Montage のセクション

[REGION:note]
これらの色は **[Editor Preferences (エディタの環境設定)]** の中の **Animation Editor** の環境設定で編集することができます。
[/REGION]

トラックのノードにカーソルを乗せると、そのノードの説明をするツールチップが表示されます。

![](ElementTiming2.png)

トラックの右側に表示されるドロップダウン メニューで、別のエレメントの表示に切り替えます。

![](ElementTiming3.png)

## Notifies 領域

![](NotifiesArea.png)

[INCLUDE:Engine/Animation/Sequences\Notifies#Intro]

[REGION:note]
詳細は、 [](Engine/Animation/Sequences\Notifies) を参照してください。
[/REGION]

## Curves 領域

![](CurvesArea.png)

[INCLUDE:Engine/Animation/Sequences\Curves#Intro]

[REGION:note]
詳細は、 [](Engine/Animation/Sequences\Curves) を参照してください。
[/REGION]


## モンタージュの作成
**子 Anim Montage** は、ゲームプレイに影響を与えずに、通知の再作成や維持管理、複数アセットに対するその他の詳細を必要とせずにアニメーションの変化形を便利に作成することができます。この使用例としては、RTS ゲームのユニット (部隊) の自動攻撃アニメーションや、RPG やアクション ゲームでキャラクターが持っている武器や装着しているアーマーなどの種類に応じてアイドル アニメーションを変更するなどが考えられます。子 Anim Montage は既存の Animation Montage から "Create Child Montage" コンテキスト メニュー オプションを使って作成することができます。

![](CreateChildMontage.png)

新しいモンタージュはオリジナルのものと同じ名前ですが最後に "_Child" が追加されます。

![](ChildAnimMontageCB.png)

[REGION:note]
子 Anim Montage は標準の Anim Montage とは別のクラスではありませんが (両方とも `UAnimMontage`)、子 Anim Montage は他の子 Anim Montage の親として使用することはできません。
[/REGION]

子 Anim Montage を編集する場合、インターフェースのすべての編集可能部分は、Slot Track を除いて色が薄くなり、非アクティブになります。Slot Track はアニメーションのオーバーライドが可能になる特殊なモードです。新規アニメーションは追加できず、アニメーションの詳細 (再生速度など) は編集不可になります。これはゲームプレイに影響を与えずに最小限の労力で様々なアニメーションを作るのに役立ちます。アニメーションそのもののタイミング、すべての通知イベントが同一であることを把握し、オリジナルのモンタージュとその子を自由に選ぶことができるからです。子 Anim Montage を編集する場合、親から変更されていないアニメーションは緑で表示されます。オーバーライドされたアニメーションは黄色で表示されます。

![](AnimMontageSlot.png)

![](ChildAnimMontageSlot.png)

上の画像のアニメーションに置き換えられるものは、子 Anim Montage のエディタ ウィンドウの黄色のボックスに表示されます。 

長さが違ってもアニメーションを別のものと置き換えることは可能です。エンジンが置き換えたアニメーションの再生速度、開始時間、終了時間を自動的に調整し、オリジナルと同等の部分を使い、実行するようにします。例えば、開始時間 0.5 で終了時間 1.0 の 1 秒のアニメーションを 2 秒のアニメーションで置き換えると、2 秒のアニメーションが開始時間 1.0 、終了時間 2.0 で再生し、1 秒のアニメーションの倍の速度で再生します。置き換えたアニメーションは、常にオリジナルのスロットにぴったりと入ります。

## モンタージュの再生

モンタージュは多くの方法で再生できます。 

* **スケルタルメッシュ** の **Anim to Play** として割り当てることができます。
* **ブループリント** のスクリプトまたは C++ で直接呼び出すことができます。
* **Animation ブループリント** の一部として **Animation Graph** に組み込むことができます。

[REGION:note]
Animation ブループリント モンタージュを使用する方法については、[](Engine/Animation/AnimHowTo/AdditiveAnimations) をご覧ください。この例では、同時に 2 つのアニメーションを互いに独立して行うことができるキャラクターを見ます。この場合、キャラクターは移動しながらシューティングします。
[/REGION]

### 複数モンタージュの再生

バージョン 4.6 より前は、一度にひとつのモンタージュしか再生できませんでした。しかし、4.6 以降は、 **Anim Slots** と **Anim Groups** を使用してお好きな数だけモンタージュを再生できるようになりました。

その仕組みを簡単に説明します。 

1. アニメーションは、Anim グループに分けられます。グループ毎に単一のモンタージュをプレイすることができます。同時に別のモンタージュを再生したい場合、それに対して新規 Anim グループを作成することができます。
1. Anim Groups と Anim Slots は、 **Persona** 内の **Anim Slot Manager** タブに集められます (以下の [Anim Slot Manager](#animslotmanager) を参照)。
1. ドロップダウン UI を使用して有効なスロットの中から選択することができます。
1. モンタージュを新規作成すると、 Slot ノードは 1 個の **Default Slot** から始まるため、ただちに機能します。

###Anim Slot Manager

* Anim Slot Manager は、アニメーションのスロットおよびグループ名を管理するツールです。階層を表示したり、変更を行うことができます。虫眼鏡アイコン (以下の図) をクリックして **Persona** のモンタージュ内で Anim Slot Manager を開くことができます。

![](OpenAnimSlotManger.png)

Anim Slot Manager が開きます。

![](AnimSlotManager.png)

グループとスロットは、**Skeleton** アセット内に保存されるので、同一ファミリーの Animation ブループリントと Montage はすべて、同一の設定を使用することができます。Anim Slot Manager 内の **Save** ボタンは、Skeleton アセットへの変更を加えるたびにそれを簡単に保存できるようにするためのものです。

* スロット名を右クリックすると、コンテキスト メニューが表示されて、必要に応じて別のグループへ移動することができます。これで作成したスロットの管理、配置、別のグループに移動、適宜整理することが簡単にできるようになります。

![](SlotClicking.png)

### モンタージュのトラックでスロットを編集する

以下は **モンタージュ エディタ** の例です。ドロップダウン ボックス (ハイライトされています) には、トラックで利用可能なスロットが一覧表示されます。

![](SlotExample1.png)

スロットやグループを新規作成する場合は、虫眼鏡アイコンをクリックすると、**Anim Slot Manager** が開きます。

上部のステータスバーには、モンタージュが属しているグループが表示されます。これは最初のトラックのスロットによって決まります。 

![](SlotExample2.png)

複数のスロットがあり、その構成に問題がある場合はステータスバーに表示されます。たとえば、異なるグループに属するスロットを組み合わせた場合は、警告が表示され、問題の詳細を見ることができます。

![](SlotExample3.png)

### Animation ブループリントでスロットを編集する

Animation ブループリントの AnimGraph で **Slot** ノードを追加して、これを選択するとモンタージュのトラック ビューのオプションと同じものを見ることができます。 

![](Slotnode.png)

ここから、ドロップダウン ボックスを使って既存スロット名を選択し、虫眼鏡アイコンを使って Anim Slot Manager を開くことができます。 

### 最後に

* 以前の構成と下位互換性があります。既存のスロットが「デフォルト グループ」の一部になっていること以外は、違いに気が付かないはずです。 
* Montage ブループリントと C++ API が強化されて、Montage アセットの参照を受け取れるようになりました。これによって、同時に再生する異なるモンタージュを制御できるようになります。例として、**Montage Set Play Rate** 関数をご覧ください。 


<!-------------------- Example removed.This should be a HowTo.

## モンタージュの実例


この例では、上体のみで再生する攻撃アニメーションと一緒に、あらゆる方向へ自由に走り回ることができるキャラクターを作成します。この攻撃には、ゲーム中に発生する複数のアニメーションが設定されています。これは、モンタージュの組み立てを表現し、イベントグラフで制御する方法や AnimGraph 内へブレンドする方法を表現する完璧な方法です。

しかし、いくつかの事前設定が必要となります。

* 移動を定義するステートマシンが既にあります。これは、Third Person Project テンプレートで使用したステートマシンと同じです。
* アーティストが作成したいくつかのアニメーションをつなげて、モンタージュを作成します。
* 入力情報を取得する [Character Blueprint クラス](Engine\Blueprints\UserGuide\Types\ClassBlueprint\Creation) を作成しました。 
 * この例の場合、 **IsAttacking** Boolean は **左マウスボタン** を押すと TRUE に、マウスボタンを解放すると FALSE に設定されます。 
  ![](CharacterBlueprint.png)

### モンタージュの作成

モンタージュは簡単に作成できます。**コンテンツ ブラウザ** で **右クリック** して、 **[Animation] > [Animation Montage]** の順に選択するだけです。既存のアニメーション シーケンスを **右クリック** して、コンテキスト メニューから **[Create Montage (モンタージュを作成)]** を選択して作成することもできます。選択したアニムシーケンスがデフォルト スロットにセットアップされた状態で、新規モンタージュが自動作成されます。

![](MakeMontage.png)

###モンタージュの設定

最初にスロットに名前を付けます。このモンタージュに 1 つだけ名前を付ける必要があります。上半身のみに攻撃を与えるため、ここでは「Upper Body」と名前を付けるのが自然です。その後必要なアニメーションをこのスロットへドラッグ / ドロップします。アニメーションは、以下の動作を行います。

* 右から左へハンマーを振ります
* 左から右へハンマーを振ります
* 右から左へハンマーを振り終わった後にアイドルステートへ戻ります
* 左から右へハンマーを振り終わった後にアイドルステートへ戻ります

[REGION:note]
ハンマーを振りかざす 2 つのアニメーションは、アニメーションが開始するポーズと同じポーズで終了します。つまり、2 つのアニメーションをループで連続再生すると、キャラクターはシームレスにハンマーをあちこちへ振りかざします。
[/REGION]

順序は重要ではないため、まず最初に 2 つのアニメーションを用意して、連続させると後の作業を簡略化することができます。

![](MontageSetup.png)


### セクションの作成

次に、必要時にブループリント コードでクエリや呼出しができるように、モンタージュのアニメーションを分割していきます。モンタージュ領域上部の Section トラックをクリックしながら、**右クリック** して **[Add New Montage Section (新規 Mondage セクションを追加)]** を選択するだけです。 

この例は、各セクションに比較的簡単な名前を使用しました。モンタージュに表示される Default セクションを置き換えたことに注意してください (新しい Default を作成し、古い Default を削除するには、**Delete Montage Section** を **右クリック** して選択します)。必要に応じてこれらのセクションを [Section Track] に沿ってドラッグすることもできます。マウスを解放すると、2 つのアニメーションセグメント間の境界線でセクションが多少スナップすることが分かります。この手法を作業に役立ててください。

![](AddNewSections.png)



### セクション関係の定義


セクションが作成されたので、[Sections Area] を使用してこれらの間に特別な関係性を定義していきます。例えば、Swing1 と Swing2 のセクションの関係を、ループで交互に連続再生するように定義します。これはとても実用的な手法です。まず最初に、デフォルトの関係を消去するために **[Clear]** ボタンをクリックします。次に、トラックに Swing1 を選択して、セクション領域上部にある緑でラベル表示されている Swing2 をクリックします。Swing2 トラックが削除されて、Swing1 トラックに Swing2 トラックが追加されます。

![](Swing2Track.png)

このプロセスを繰り返した場合、新規の Swing2 セグメントをクリックした後に Swing1 ボタンをクリックすると、ループを作成していることをシステムが認識し、トラックが青色表示に変わります。つまり、Swing1 と Swing2 のセグメントはループ セクションとみなされます。これらのセグメントは連続再生されて、無期限に反復されます。

![](LoopingTracks.png)

###分岐点の設定

次にループを継続、または攻撃アニメーションに想定される 2 つの結果の 1 つへジャンプするかをテストするために、分岐点をいくつか作成します。分岐点トラックのどこかを右クリックして **[New Branch Point (新規の分岐点)]** を選択するのみです。この分岐点に 「Swng_1_End」と「Swing_2_End」 と名付けました。対応するセクションの可能な限りぎりぎりの最後の瞬間で発行されるように、マウスホイールを使って細かくズームインします。つまり、2 点間から多少左寄りの境界線に配置します。

![](BranchPointsSetUp.png)



[REGION:note]
分岐点の代わりに通知を使用する類似システムも設定できますが、その場合タイムラインに沿って多少早めに発行しなくてはいけません。また、Animation Blueprint Event Graph は、例で使用している **[Montage Jump to Section]** ノードによる直接的な切り替えではなく、**[Montage Set Next Section]** ノードを使用して適切な最終アニメーションをキューに入れます。通知は非同期であるため、通知による設定はパフォーマンス負荷が多少小さくなります。これは論理上の例ですが、他の手法もお伝えしたかったのです。
[/REGION]


### AnimGraph の設定

この時点でモンタージュは全て設定されました。次に AnimGraph を設定して、モンタージュの結果をこれに読み込ませます。大変簡単なプロセスですが、進め方に注意を払わなくてはいけません。AnimGraph はこのような設定で開始します。画像は、ステートマシンの結果のみを表示しています。

![](StateMachineResult.png)


モンタージュでは、「Spine_01」ボーン (ウエスト) よりも上の部分だけを再生させるため、 **Layered Blend per Bone** ノードを使用します。[Blend Pose] を追加して、ウェイトを「1」に設定します。また、ノードのプロパティで Blend Pose と Spine_01 を関連付けます。その後 **Slot** ノードを導入して、作成したスロット名である UpperBody へ設定します。ここで問題が発生します。

![](SlotAndBlend.png)

Slot ノードは、モンタージュ再生の終了後に使用する「Source」接続が必要です。この接続なしでは、モンタージュ終了後にキャラクターの腰から上は T ポーズに戻ってしまいます。しかしステートマシンは、**Layered Blend per Bone** ノードの「Base Pose」と **Slot** ノードの「Source」両方へ接続することはできません。解決法？**Cache** ノードを使用します!ステートマシンの結果を Cache ノードに格納して、その後必要な両入力値と接続するために **Cached Pose** ノードを作成します。これはさまざまな場面で活用するために、ステートマシンの結果を変数へ格納する方法と多少似ています。この例では、Cache ノードを「 LocoCache 」と名付けます。

![](CachedLocomotion.png)

AnimGraph はこれで終了です。UpperBody Slot ノードが _任意の AimMontage からデータを受け取るとすぐに (UpperBody と名付けれたスロット名であれば全てのモンタージュを使用可能)、ブレンドされます。データを受け取らない時点でノードはステートマシンの結果へ戻ります。


### イベントグラフの設定

イベントグラフの設定は極めて基本的なものです。**Event Blueprint Update Animation** ノードを使い **Get Player Character** ノードの出力ピンからドラッグすれば、 **Character ブループリント** (_MyCharacter_ in this example) へ **キャストして (Cast To) ** ブループリントの変数と機能を利用することができます (ブループリント間通信の詳細は [ブループリント通信](Engine\Blueprints\UserGuide\BlueprintComms) を参照してください)。 

_クリックしてフルサイズで表示_
[REGION:lightbox]
[![](PlayMontageEventGraph.png)(w:1020)](PlayMontageEventGraph.png)
[/REGION]

Character ブループリントから受け取った **IsAttacking** 変数が TRUE かどうかをまず確認し、 TRUE であればモンタージュが既に再生しているかを確認します。モンタージュが再生中であれば、再び再生する必要はありませんが、もし再生していない場合はモンタージュを再生します。これにより、再生途中のアニメーションの再スタートを防ぎます。再スタートは見栄えが悪くなります。 

**Cast To** ノードから伸びている **IsAttacking** ノードをドラッグして、マウスボタンがまだ押されたままかを確認します。押されていない場合、ループのどちらの半分が再生されたかに応じて、適切な最終アニメーションへジャンプします。Branch Point Events を作成するには、 **[Add Montage Branching Point Event (Montage Branching Point Event を追加)]** の下の適切なイベントを **右クリック** および選択します。

![](EndLoopEventGraph.png)

これで終わりです！コンパイルすると、キャラクターはボタンが押されている間中ハンマーを振りかざし、マウスボタンが解放されるとインテリジェントな最終アニメーションを実行します！


[OBJECT:EmbeddedVideo]
[PARAMLITERAL:width]
640
[/PARAMLITERAL]
[PARAMLITERAL:height]
360
[/PARAMLITERAL]
[PARAMLITERAL:videoid]
6eMxjbkn6hs
[/PARAMLITERAL]
[/OBJECT]

-------------------->
