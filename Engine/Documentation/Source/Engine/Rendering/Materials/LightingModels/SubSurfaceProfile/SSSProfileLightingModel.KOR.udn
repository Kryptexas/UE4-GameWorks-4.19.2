INTSourceChangelist:2699405
Availability:Public
Title:서브서피스 프로파일 셰이딩 모델
Crumbs: %ROOT%, Engine, Engine/Rendering/Materials
Description:머티리얼에서 사용할 수 있는 서브서피스 프로파일 셰이딩 모델에 대한 설명과 기술적 세부사항입니다.
Version: 4.9

[TOC(start:2)]



현실적으로 보이는 사람 피부 렌더링을 위한 능력은, 요즘 비디오 게임 엔진에 있어서 필수적인 것입니다. 이를 충족시키기 위해 언리얼 엔진 4 (UE4) 는 현재 피부나 밀랍같은 표면에 사용할 수 있는 셰이딩 모델, **Subsurface Profile** (서브서피스 프로파일)을 제공합니다.
서브서피스 프로파일 셰이딩 모델에는 **서브서피스** 셰이딩 모델과 비슷한 프로퍼티가 있긴 하지만, 그 렌더링 방식에서 핵심적인 차이가 있습니다. 
서브서피스 프로파일은 스크린 스페이스를 기반으로 하는 렌더링 접근법을 사용합니다. 사람 피부에서 볼 수 있는 미묘한 서브서피스 이펙트, 이를테면 귀와 같은 곳에서 보이는 후방 산란 이펙트 표현에 더욱 좋기 때문입니다.
다음 문서에서는 서브서피스 프로파일이란 무엇인지, 어떻게 사용할 수 있을지에 대해 다뤄봅니다.

[OBJECT:ComparisonSlider]
	[PARAM:before]
	![Not using SubsurfaceProfile](Results_1.png)(w:700 convert:false)
	[/PARAM]
	[PARAM:after]
	![Using SubsurfaceProfile](Results_2.png)(w:700 convert:false)
	[/PARAM]
[/OBJECT]


[Region:note]
3D 스캔 헤드 모델 제공 및 도움을 주신 Lee Perry-Smith 와 그의 회사 [Infinite Realities] (http://ir-ltd.net) 에 감사드립니다.
[/region]


## 서브서피스 프로파일이란

서브서피스 스캐터링 프로파일에는 서브서피스 스캐터링을 어떻게 렌더링할지에 대한 정보가 저장됩니다.
다른 액터와 마찬가지로 **콘텐츠 브라우저** 에서 생성, 공유, 저장 가능합니다.
서브서피스 스캐터링 프로파일은 표면 아래의 빛이 산란하는 거리, 표면 아래 부분의 색, 빛이 물체를 빠져나간 이후의 감쇠 색에 대한 아티스트 주도형 데이터를 저장하는 방식으로 작동합니다.
그 후 이 데이터를 서브서피스 머티리얼에 적용시켜 표면 아래 부분의 모양에 영향을 끼칩니다.
서브서피스 프로파일은 대화식 조절도 가능하여, 머티리얼을 다시 컴파일하지 않아도 수정 결과를 확인할 수 있습니다.




## 서브서피스 프로파일 활성화, 생성 및 사용

머티리얼에서 서브서피스 프로파일을 사용하려면, 먼저 머티리얼의 **디테일** 패널에서 **셰이딩 모델** 을 **서브서피스 프로파일** 로 설정하여 서브서피스 프로파일을 사용할 머티리얼을 활성화시켜줘야 합니다.
**서브서비스 프로파일** 입력에 다른 서브서피스 프로파일을 연결하여 머티리얼에 사용할 서브서피스 프로파일을 덮어쓸 수 있습니다.

[REGION:tip]
서브서피스 프로파일 기본 세팅은 백인 피부에 가깝습니다. 하지만 이는 현실적인 피부를 위한 한 가지 성분에 지나지 않습니다. _항상 텍스처의 베이스 컬러가 서브서피스 스캐터링 프로파일에 맞는지 확인하도록 하세요._
[/REGION]

![Enable SubsurfaceProfile](1.png)

서브서피스 프로파일 역시 머티리얼 인스턴스에서 덮어쓸 수 있습니다. 그러기 위해서는 먼저 변경하고자 하는 머티리얼 인스턴스를 열어야 합니다.
그런 다음 머티리얼 인스턴스의 **디테일** 섹션에서, **Override Subsurface Profile** (서브서피스 프로파일 덮어쓰기)를 켠 다음 **Subsurface Profile** 입력에 사용하고자 하는 서브서피스 프로파일을 제공해 주면 됩니다.

![](6.png)

서브서피스 프로파일을 만들려면, 먼저 **콘텐츠 브라우저** 에서 **우클릭** 합니다. **머티리얼 & 텍스처** 옵션을 선택한 다음 **서브서피스 프로파일** 옵션을 선택합니다.

![Create SubsurfaceProfile](2.png)

[region:note]
지정된 서브서피스 프로파일이 없으면, 백인 피부인 기본 서브서피스 프로파일을 사용합니다.
[/region] 


서브서피스 프로파일 편집은 **콘텐츠 브라우저** 에서 **더블클릭** 하여 열면 됩니다.
연 이후 서브서피스 스캐터링 프로파일의 각 프로퍼티에 키보드로 숫자를 입력하거나 컬러 바를 **좌클릭** 하여 색 선택기를 통해 조정할 수 있습니다.


![Tweak SubsurfaceProfile](3.png)

* **Scatter Radius:** 이 월드 스페이스 유닛 거리만큼 산란시킵니다.

* **Subsurface Color:** 서브서피스 이펙트의 가중치로 사용할 수 있는 서브서피스 컬러입니다. 검정은 서브서피스 스캐터링이 없다는 뜻입니다.
하양은 모든 라이팅이 머티리얼에 들어가 산란된다는 뜻입니다. 회색조 이외의 값은 표면에 들어선 라이팅이 좀 더 복잡한 셰이딩이 나오도록 하는 
색 기여도에 대해 더욱 세밀한 제어가 가능합니다.

* **Falloff Color:** 라이트가 머티리얼에 들어간 이후의 머티리얼 산란색을 정의합니다. 
산란이 일어나는 곳에 좀 더 복잡한 셰이딩 변화를 얻고자 한다면, 여기에 선명한 색 사용을 피해야 할 것입니다.

[region:note]
 전체 계산은 에너지 보존 법칙을 따르므로, (예전/기타 서브서피스 메소드와는 달리) 산란을 통해 빛이 더 세지는 것은 불가능합니다.
[/region]



## 머티리얼 입력 채널

'스크린 스페이스 서브서피스' 셰이딩 프로파일은 '릿' 셰이딩 모델과 크게 다르지 않지만, 큰 차이점은 '메탈릭' 입력의 용도가 변경되어 사용할 수 없다는 점입니다.

**Base Color Input:** 베이스 컬러 입력은 디퓨즈 라이팅에 평소처럼 사용됩니다. 스크린 스페이스 서브서피스 스캐터링은 색이나 밝기의 변화 없이 라이팅을 주변 픽셀에 재배포할 뿐이기에, 별도의 서브서피스 스캐터링 컬러는 없습니다.
즉 머티리얼이 특정한 색으로 산란해야 한다면, 베이스 컬러의 일부로 표현해 줘야 합니다.
베이스 컬러는 스캐터링과 디퓨즈 라이팅을 구분할 수 없는 먼 거리에서 봤을 때의 머티리얼 최종 색입니다.

[REGION:note]
 사람 피부는 표면 아래 활기찬 빨간색이 흐르는 얇고 창백한 레이어로 볼 수 있으며, 그것이 기본 색이라 할 수 있습니다. 사람 피부의 가시 거리는 약 1.2 cm 정도로, 그것이 서브서피스 프로파일의 기본값입니다.
[/region]

**Metallic Input:** 메탈릭 입력 채널은 서브서피스 프로파일에는 사용할 수 없습니다. 메탈릭 입력에 대한 GBuffer 공간이 서브서피스 프로파일 데이터를 수용하도록 용도 변경되었기 때문입니다.

**Opacity Input:** 오파시티 입력 채널은 서브서피스 스캐터링 공헌을 마스킹하는 데 사용됩니다.
0 과 1 사이 값을 통해 서브서피스 스캐터링 강도가 다른 여러 영역 사이를 부드럽게 전환시키는 방식으로 작동합니다.
예를 들어 오파시티 입력에 값을 0 입력하면, 서브서피스 스캐터링이 꺼집니다.
값을 1 입력하면 서브서피스 스캐터링이 최대로 표시됩니다.
서브서피스 스캐터링 강약을 더욱 잘 조절하기 위해서는, 마스크 텍스처를 사용하는 것이 좋습니다.  
마스크 텍스처의 값이 1 또는 하양에 가까운 곳은 스캐터링 이펙트가 세지고, 0 또는 검정에 가까운 곳은 약해집니다.
서브서피스 컬러를 조절하면 너무 어두워지는 영역을 보정하는 데 도움이 되나, **밝은 색** 을 사용하면 서브서피스 스캐터링이 늘어납니다.

여기서는 마스크를 사용하여 하나의 머티리얼로 두 개의 표면 유형을 렌더링한 것을 볼 수 있습니다. 전환이 부드러울 뿐만 아니라 트라이앵글 경계에 제한되지 않은 것이 보입니다.

[REGION:lightbox]
[![](4.png)(w:920 convert:false)](4.png)
[/REGION]



## 테크니컬 디테일

현재 서브서피스 스캐터링 프로파일 셰이딩 모델은 릿(램버트 디퓨즈, 스페큘러에는 GGX, 메탈릭 없음)과 크게 다르지 않습니다.
 대부분의 마법은 모든 라이팅 계산 이후의 포스트 프로세스에서 일어납니다.

[REGION:note]
서브서피스 스캐터링 프로파일은 [Jorge Jimenez](http://www.iryoku.com/) 의 작업물을 기반으로 합니다. 이 홈페이지에서 3D 이미지를 보다 현실적으로 만드는 데 관련된 유용한 팁을 확인해 보실 수 있습니다.
[/REGION]

서브서피스 머티리얼 위에 스페큘러를 지원하기 위해 비 스페큘러 (뷰에 의존하지 않는) 라이팅 공헌을 분할시키고 다운 샘플링하여 퍼포먼스를 높였습니다.
가우시안 블러와 비슷하게 (분리가능 커널을 가정하고) 이미지를 2 패스 포스트 프로세스로 필터링합니다.
필터 커널은 GBuffer 에 저장된 서브서피스 스캐터링 프로파일에 의존합니다 (씬별로 최대 255 개의 활성 프로파일).
커널에는 착색된 웨이트와 지정된 샘플 위치가 있어, (유닛/cm 으로 정의된) 프로파일에서 스케일 조절 가능합니다.
최종 단계로, 산란된 빛 공헌을 최대 해상도 이미지와 다시 합칩니다. 뷰 의존 / 비의존 라이팅을 분리시키기 위해, 씬 컬러 알파 채널에 웨이팅 부분을 저장합니다.
이러한 추정법은 64 비트 렌더 타겟을 필요로 하며 (r.SceneColorFormat 참고) 대부분의 경우에 정상 작동합니다.

스페큘러는 성공적으로 잡아내지만, 그 스페큘러 픽셀에 대해서 좀 더 탈색된 뷰 비의존 색을 얻습니다. 이를 모든 라이팅 패스에 대해 두 개의 32 비트 렌더 타겟을 사용하여 개선 가능합니다. 이는 메모리 대역폭은 같지만 일부 하드웨어에서는 더 느릴 수 있습니다. 이 부분은 (추가되는 코드 복잡도로 인해) 바뀔 수도 있는 부분입니다.

이는 블러 적용 전 스페큘러를 제거한 예제입니다. 최종 (가장 오른쪽) 이미지의 스페큘러 리플렉션이 얼마나 산뜻하고 부드러운지 보세요. 바로 원하던 이펙트입니다.

[REGION:lightbox]
[![](Good_Combination.png)(w:920 convert:false)](Good_Combination.png)
[/REGION]

블러 적용 전 스페큘러를 제거하지 않은 예제는 이렇습니다. 최종 (가장 오른쪽) 이미지의 스페큘러 리플렉션이 얼마나 무디고 약간 늘어져 보이는지 보세요. 이 이펙트를 제대로 렌더링해낸 방식은 아닙니다.

[REGION:lightbox]
[![](Bad_Combination.png)(w:920 convert:false)](Bad_Combination.png)
[/REGION]

## Scalability 및 콘솔 명령

높은 퀄리티의 비주얼과 더 나은 퍼포먼스 사이의 적정선을 찾는 데 도움이 되는 스케일 및 퍼포먼스 콘솔 명령이 몇 가지 있습니다.

**r.SSS.Scale**: 포스트 프로세스 패스를 끄거나 이펙트 스케일을 조절하여 빠른 실험이 가능합니다.

**r.SSS.SampleSet**: 샘플 수를 줄여 이펙트가 빠르게 실행되도록 합니다. 하지만 퀄리티가 낮아지거나 렌더링 부작용이 생길 수 있습니다.

다음 이미지는 시스템 내부적인 부분을 약간 더 보여줍니다. **ShowFlag.VisualizeSSS 1** 명령으로 켤 수 있습니다.

[REGION:lightbox]
[![](5.png)(w:920 convert:false)](5.png)
[/REGION]

서브서피스 스캐터링 프로파일 셰이딩 모델은 피부 렌더링에 있어 한 단계 발전된 것이지만, 그 기능에 약간의 제한이 있습니다.
 _참고로 이 시스템이 개선됨에 따라 이 목록은 바뀔 수 있습니다. _

* 이 기능은 디퍼드 렌더링 이외 (모바일) 모드에서는 작동하지 않습니다.
* 스크린 스캐터 반경을 크게 설정하면 극한의 라이팅 조건에서 띠 부작용이 생깁니다.
* 현재 빛의 뒷면산란이 없습니다.
* 현재 SSS 머티리얼이 비 SSS 머티리얼에 가려질(occluded) 때 회색 윤곽선이 나타납니다.




## 크레딧

두상 모델 제공과 도움을 주신 Lee Perry-Smith 와 그의 회사 [Infinite Realities](http://ir-ltd.net) 에 특별한 감사 말씀 올립니다.
이 기능에 자신의 작업물을 기반으로 한 구현을 공개해 주신 [Jorge Jimenez](http://www.iryoku.com/) 께도 매우 각별한 감사 말씀 올립니다.






