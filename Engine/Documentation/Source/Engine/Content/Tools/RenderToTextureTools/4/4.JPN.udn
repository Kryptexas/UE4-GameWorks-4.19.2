INTSourceChangelist:2602263
Availability:Public
Title:ノーマライズした深度マップをレンダリングする
Crumbs:%ROOT%, Engine, Engine/Content, Engine/Content/Tools/RenderToTextureTools
Description:

[TOC(start:2)]

この関数は、ローカルのスタティックメッシュの深度マップをレンダリングします。これにより、完全にライティングなしのマテリアルを使用して、生き生きとした動的シャドウの外観を模倣できます。
 
![](17.jpg)

基本的にノーマライズした深度マテリアルを使用してメッシュのトップダウンのスクリーンショットを撮ることで深度をレンダリングします。深度は UV 空間ではなく正投影で保存されるため、テクスチャ密度は密集した木々で劇的に高くなります。

この機能は、Apple Metal API Zen デモの桜の木で使用されています。

この技術には、固有の長所と若干の短所がいくつかあります

**長所**

1. 複雑な木々の場合、アンラップした UV は「縦方向のオーバーラップ」のために低解像度になります。シャドウ深度テクスチャではアンラップで解像度は失われず、一段と高い解像度を実現します。 
1. ライトマスで良好なシャドウを得るのは不可能な、カメラの方向を向くスプライトのようなものに対して正確なライティングを頂点シェーダで簡単にベイクできます。これが、この関数が存在する主な理由です。
1. 結果として得られる深度テクスチャでは、リアルなエフェクトを得るために深度のバイアスと、ライトの透過距離を微調整できます。 
1. 結果として得られるテクスチャはコリジョンのないヒドゥンゲームのスタティックメッシュに配置することもできます。これは、地面やプレイヤーを含むジオメトリへの木のシャドウ キャスターとして機能します。これはシャドウイングのパフォーマンスを大幅に向上させます。
1. 非常にハイポリゴンな木々を使用したいがライトマスのリビルドが何らかの理由で問題があり、カスケードのシャドウマップでは求めるクオリティにはならない壮大な森のシーンでは、これは優れた代替方法になります。壮大なシーンを埋めて、木々を配置したらすぐに遠くでも同じように見栄えよくすることができます。
1. メインの計算は頂点シェーダが行い、見栄えの良いライティング無しのマテリアルは Zen デモで実証されているようにモバイルでも十分実行可能なほど負荷が低くなっています。

**短所**

1. 単純なケースでライトマスを使用してライティングをベイクするのに比べてコンテンツ制作コストは幾分高くなります。しかし、上記の理由から作業が増えても正当化される場合があります。
1. 最終結果のシャドウのブラー制御は困難です。手作業でブラーを適用したか LOD バイアスを使用しない限り鮮明に見える傾向があるためです。
1. これは静的なシーンでのみ機能します。単一のライト ビューからベイクされているため、実際にシャドウの角度を変更させることはできません。必要があればライトを回転させるように「見せかける」パラメータがいくつかあります。しかし、成果物のクオリティははるかに低くなり、その見せかけの近似は球状に近い木々に限りうまくいきます。この場合、中央からの回転であまり変化しないためです。
1. ライティングなしのマテリアルでライトマスのバウンスライトで失敗し、再度微調整し直すことになります。

## 深度マップをベイクする

![](16.jpg)

Light Vector: ビューをキャプチャするライトベクターを指定するか、レベルに配置した指向性ライト アクタにリンクすることができます。

日中 12 時のライトベクターを表現するには、0,0,-1 と入力します。

| プロパティ | 説明 |
| --- | --- |
| **Directional Light** | レベルから使用する指向性ライトを選択したら、上記のライトベクター設定は無視され、かわりにこのライトが使用されます。 |
| **Depth Map Static Mesh** | キャプチャしたいスタティックメッシュを入れる場所です。 |
| **Depth Material Mask Textures** | ここでマテリアルを作成したり、指定したりする必要はありません。配列にある各要素に対して 1 つずつマテリアルが自動作成されます。配列にある要素でブランクのものがあれば、白いマスクが使用されます。スタティックメッシュに 3 つのセクションがあれば、配列に 3 つの空のアイテムを追加するだけで、マテリアルが作成されます。また、メッシュの一部にマスク テクスチャがあれば、ここで指定することができます。望ましいマテリアル ID に合致する配列アイテムに適用するテクスチャを指定します。 |
| **Mask Channel** | この設定では、どのチャンネルにマスクがあるかを指定できます。これはマスクがチャンネルでパックされたテクスチャの一部であり、特定のチャンネルを必要とする場合に役立ちます。
| **Use Level Meshes for Depth** |単独のメッシュを指定する代わりに、「背景」シートの上に手動で配置した単一メッシュまたはメッシュのグループに対して深度をキャプチャします。これは他と関連性がない滅多に使用されないケースです。または、実際に RenderToTexture_LevelBP を既存レベルに持ってきてメッシュのグループに対して深度マップをキャプチャすることができます。このオプションを使用する場合、境界は完全にカスタムでなければならないため、マテリアルで使用しなければならない高度な設定がいくつかあります。 |
| **Scale XY** | このツールはオブジェクトの球体の境界を使用し、キャプチャ領域内にオブジェクトが最適にフィットするようにします。これは、オブジェクトのエッジ周囲のデッドスペースが広くなりすぎる場合があります。この設定では、オブジェクトを手作業で若干スケーリングすることによってデッドスペースを微調整できます。ここで入力値を変更すると、マテリアルのパラメータを入力値に合うようにしなければならないため、値を 1.0 のままにすることをお勧めします。
| **Scale Z** | 上記と似ていますが、この関数はオブジェクト球体の境界を使用して、ローカル深度範囲を決定します。この深度範囲はノーマライズされた深度結果を生成するために使用されます。ほとんどの場合、デフォルト値 1 を使用しますが、精度を上げるために 0 - 1 の範囲を十分に使用するように範囲をクリップしたい場合、赤色が現れるまで (ピクセルがローカル 0 - 1 範囲外にあり、平坦化されることを意味します!) この設定を減らすことができます。設定をここで変更した場合、後で実際のマテリアルでこれと一致する値が設定される必要があります。そのため、変更を正当化する理由がない限り、この値はそのままにすることをお勧めします。
| **Fit Vector and Scale Info Onto Texture** | キャプチャで使用した設定を記憶するためにこのオプションは便利です。有効にすると、上記の値でテキストをシート上に記述します。次の 2 つの設定では、テキストをスケーリングし、移動できます。
| **Text Size** | 情報テキストのサイズです。 |
| **Text Locations** | これは配列であるため、空きがあれば各テキスト エレメントをカスタム位置に移動できます。テキスト行が 2 行あるため、両方を移動するために 2 つのアイテムを追加する必要があります。 |

メッシュが指定され、Leaves material ID に対してマスク テクスチャが指定された状態で、以下のようになります。

![](18.jpg)

深度マップのレンダリングは、以前と比べて若干手順が異なります。

この関数は、「Capture Settings」で選択されたバッファは無視し、解像度の乗数のみに配慮します。

新規ウィンドウでゲームを再生し、コンソールで "renderdepth" と入力し、Enter キーを押します。

Pawn Blueprint も "viewmode unlit" を設定しなければならないため、この場合のコマンドは異なります。

## 深度マップをマテリアルのシャドウとして使用する

深度マップを使用するには、新規マテリアルを作成しなければなりません。マテリアル内部で、"VolumeShadowMap" マテリアル関数を配置しなければなりません。
 
![](20.JPG)

MaterialFunction '/Engine/ArtTools/RenderToTexture/MaterialFunctions/VolumeShadowMap.VolumeShadowMap'

このマテリアル関数は現時点では、ほとんどフォリッジのセットアップ用のものであるということに注意してください。計算される直接光コンポーネントはなく、シャドウのみです。そのため、ライトから離れてカーブするソリッド ジオメトリ上のシャドウの見た目はそれほどよくなりません。投影ベクトルと頂点法線で、マニュアルでドット積を行い、 0-1 でクランプすることでこれを修正できます。

これは通常のスタティックメッシュで使用されているシャドウの例です。このスタティックメッシュは、互いの上に配置されたいくつかの円柱、ボックス、球体です。

![](21.jpg)
 
左：上から見たもの、右：下側側面から見たもの。シャドウだけでなく、自己シャドウの正確さ (または直接の N dot L 成分が欠落していることによる自己シャドウの欠落) もわかります。

| 入力ピン | 説明 |
| --- | --- |
| **Position** (V3) |  レベルに配置されたスタティックメッシュのグループをベイクする場合に限り使用します。このオプションはまだ実験的なものであるため、そのまま接続しないようにすることをお勧めします。 |
| **Range** (S) | 範囲をクリップするためのものです。この値は深度マップのレンダリング中に "Scale Z" として設定された値と一致させる必要があります。 |
| **Transform Position** (B) | カスタム ライト ベクターに変形するかどうかです。デフォルトは _False_ です。つまり、正午のデフォルトのローカル位置には 0,0,-1 のライトが使用されます。|
| **Projection Vector** (V3) | 深度マップがレンダリングされるライトベクターです。ライトベクターとスケーリング情報を持つデバッグテキストをテクスチャにレンダリングする場合、使用するテクスチャでライトベクター値を持つ必要があります。そうでない場合は、レンダリング プロセス中に指定されたライトベクターを使用するか、またはデフォルトの正午の方向をオーバーライドしない場合はそのままにします。 |
| **Use Custom UVs** (B) |  デフォルトで _FALSE_ になります。これが _TRUE_ の場合、この関数は内部の UV を、頂点シェーダのコンピュータのカスタム UV を使用して計算します。これはほとんどの場合モバイルで重要になりますが、プラットフォームのタイプに関わりなくピクセル シェーダ命令を減らすことができます。_True_ の場合、関数の X、Y および Z の出力を適切なカスタム UV に接続し、正しい UV ノードを以下の 2 つの入力に接続します。 |
|  **Custom UV, XY** (V2) | カスタム UV を指定した場合、"X、Y" 出力をマテリアルのカスタム UV 入力に接続した場所のインデックスに設定されたインデックスを持つテクスチャ座標ノードを配置しなければなりません。 |
| **Custom UV, Z** (S) | カスタム UV を指定した場合、"Z" 出力をマテリアルのカスタム UV 入力に接続した場所のインデックスに設定されたインデックスを持つテクスチャ座標ノードを配置しなければなりません。正しいコンポーネントをパスするようにコンポーネントをマスクする必要があるかもしれません。 |
| **Shadow Volume Texture** (T2d) | これは、Depth Map (深度 マップ) テクスチャをテクスチャ オブジェクトまたはテクスチャ オブジェクトのパラメータとして接続する場所です。 |
| **Self Shadow Offset** | -0.01 などの小さな負の数に設定します。シャドウにバイアスをかけ、オブジェクトが自己にランダムにシャドウを表示しないようにします。 |
| **Transmission Mip Bias** | 現在、接続されていないが、後で再接続されます。透過で使用する深度マップ テクスチャに MipBias をかけることができます。
| **Opacity** (S) | 内部透過のみに使用します。この設定は「Internal Transmission Mask」出力のみに影響を与え、Shadow 出力には影響を与えません。 |
| **Shadow Accumulation Distance** (S) | シャドウが完全な黒色にどれくらい速く距離を伴いビルドされるかを微調整します。値 1.0 に設定すると、シャドウは非常に強くなります。値を 0 に減らすと、ライトはより細いオブジェクトを通過するように見えます。 |
| **Blur using offset RGB texture** (B) |  デフォルトで _FALSE_ になります。_TRUE_ の場合、色収差のように深度マップ テクスチャで R,G,B の各チャンネルをオフセットできます。この関数は続いて各チャンネルの結果をブレンドします。これにより、この技術で通常可能なものより広い / ソフトなブラーを実現します。

| 出力ピン | 説明 |
| --- | --- |
| **Internal Transmission Mask** | これは "opacity" 入力で実現する内部透過の結果です。これを別個の出力として持つと便利です。これにより、カスタム カラーで透過を乗じることができます (微調整のために VectorParameter をお勧めします)。その後、結果を以下の "Shadow" 出力に追加します。 |
| **Shadow** | メインのシャドウ結果です。使用するには、単にこのピンを必要なテクスチャおよび/または他のマテリアル命令で乗算処理します。いくつかの方法でシャドウの色合いを調整できます。1 つの良い方法としては、この Shadow 出力を使用して "Lit" カラーと "Shadow" カラーとの間で Lerp (Linear Interpolate:線形補間) すると、それぞれを直接制御するというものがあります。 |
| **XY** | カスタム UV を使用して頂点シェーダで計算を実行したい場合にのみ使用する必要があります。これを行う場合、このピンをマテリアル上のカスタム UV 入力の 1 つに接続します。 |
| **Z** | カスタム UV を使用して頂点シェーダで計算を実行したい場合にのみ使用する必要があります。これを行う場合、このピンをマテリアル上のカスタム UV 入力の 1 つに接続します。 |

Internal Transmission 設定の例

![](22.jpg)(w:920)
 
左：オパシティ=1; 中央オパシティ=0.2; 右： オパシティ = 0.1

リーフ マテリアルの透過の例

![](19.jpg)
