INTSourceChangelist:2261160
Availability:Public
Title:ゲームプレイ要素をブループリントにエクスポーズする
Crumbs: %ROOT%, Programming, Engine/Blueprints/TechnicalGuide
Description:ゲームプレイ要素をブループリントにエクスポーズするゲームプレイ プログラマのためのテクニカル ガイド

[TOC(start:2)]


## 概要

プログラマとして、ブループリントで作業を行うと、コードに高い柔軟性もたせることができるため多くのメリットがあります。たとえば、 
ゲームプレイ デザイナーは、ゲームで新タイプの武器を実装したい場合があるでしょう。プログラマとして、 
一部の重要な機能をエクスポーズすること以外は、従来行っていたように武器をコーディングします。 
こうした機能には、発射レートと Fire() 関数があります。プレイをテスト後、デザイナーは、カーブで機能するように 
銃の発射レートを変更する必要があると判断するとします。銃の発射レートを再コーディングし、ゲームを再コンパイルするのではなく、デザイナーは単にブループリントで直接発射レートを変更することができます。 
その結果、デザイナーとプログラマーの双方で 
作業時間を短縮することができます。 


##クラスをブループリントで利用可能にする

クラスから拡張するブループリントを作成するためには、クラスを **Blueprintable (ブループリントで利用可能)** として定義しなければなりません。 
これを行うには、クラス定義の前に、 `UCLASS()` マクロ内にこのキーワードを追加します。このキーワードによって 
ブループリント システムにそのクラスを認識させ、 **[New Blueprint]** ダイアログのクラス リストで表示されるようにし、 
作成中のブループリントの親として選択可能にします。

ブループリントで利用可能なクラス宣言の最も単純な形式は、以下のようなものになります。

	UCLASS(Blueprintable)
	class AMyBlueprintableClass :AActor
	{
		GENERATED_UCLASS_BODY()
	}


| キーワード | 説明 |
| -- | -- |
| **Blueprintable** | ブループリントの作成に使用可能と判断されたベースクラスとしてクラスを公開します。それ以外を継承していない限り、初期設定は NotBlueprintable です。これはサブクラスで継承されます。 |
| **BlueprintType** | ブループリントの変数に使用可能なタイプとしてクラスを公開します。 |
| **NotBlueprintable** | ブループリントを作成するためのベースクラスとして許容不可としてクラスを設定します。Blueprintable のキーワードが指定された親クラスの効果を打ち消します。 |


## 読み出し可能、書き込み可能なプロパティ

C++ クラスで定義した変数を、当該クラスから拡張するブループリントに公開するためには、その変数は、 
以下に一覧表示したキーワードのいずれかひとつを使用して、変数定義に先立ち、`UPROPERTY()` マクロ内で定義しなければなりません。 
こうしたキーワードは、ブループリント システムに変数を認識させ、 **[MyBlueprint]** パネルに表示されるようにし、 
その値を設定したり、その値にアクセスできるようにします。

	//Character's Health
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Character")
	float health;

| キーワード | 説明 |
| -- | -- |
| **BlueprintReadOnly** | このプロパティはブループリントで読むことができますが、修正はできません。 |
| **BlueprintReadWrite** | このプロパティはブループリントから読んだり書き込んだりすることができます。 |
| [REGION:tablesection]マルチキャスト デリゲートのキーワード[/REGION] ||
| **BlueprintAssignable** | ブループリントで割り当てるために、プロパティを公開しなければなりません。 |
| **BlueprintCallable** | ブループリントのグラフで呼び出すために、プロパティを公開しなければなりません。 |

##実行ファイルとオーバーライド可能な関数

ブループリントからネイティブ関数を呼び出すためには、その関数が以下にリストされているキーワードのいずれかひとつを使用して 
関数定義の前の `UFUNCTION()` マクロ内で定義されていなければなりません。このキーワードによってブループリント システムは 
コンテキスト メニューまたはパレットで表示されるように関数を認識し、グラフへの追加や、実行を可能にします。または、 
イベントの場合、オーバーライドおよび実行を可能にします。

ブループリントで呼び出し可能な関数の宣言の最も単純な形式は、以下のようなものになります。

	//Fire a Weapon
	UFUNCTION(BlueprintCallable, Category="Weapon")
	void Fire();


| キーワード | 説明 |
| -- | -- |
| [REGION:tablesection]ブループリントからネイティブへのコミュニケーション[/REGION] ||
| **BlueprintCallable** | ブループリントから呼び出し可能なネイティブ関数です。呼び出されているオブジェクトに関する何か、または他のグローバル ステートを変更するネイティブ コードを実行します。つまり、「スケジューリングされる」または他のノードに対して実行する相対的な順序を明示的に示されなければなりません。これは、白色の実行ラインで行います。すべてのブループリントで呼び出し可能な関数は、白色の実行ラインに沿って表示される順序で呼び出されます。 |
| **BlueprintPure** | ブループリントから呼び出し可能なネイティブ関数であり、呼び出されているオブジェクトに関する何か、または他のグローバル ステートを変更しないネイティブ コードを実行します。つまりこのノードを呼び出すことによって何も変更されず、単に入力を受け入れ、出力を示します。これらは、数学のノード (+、 - 、 * など) のようなものです。または変数の getter または永久に何も変更しないものです。こうしたものをスケジューリングする必要はありません。また、白色の実行ラインと接続しません。どの BlueprintCallable ノードが、こうしたノードによって作られたデータを必要としているかに基づき、コンパイラはこれらを自動的に認識します。 |
| [REGION:tablesection]ネイティブからブループリントへのコミュニケーション[/REGION] ||
| **BlueprintImplementableEvent** | ネイティブ関数をブループリントに呼び出すことができるようにする主要な方法です。これはブループリント自体に実装する仮想関数のようなものです。実装がなければ、この関数呼び出しは無視されます。BlueprintImplementableEvent が戻り値または出力パラメータを持たない場合、イベントとして表示され、 **右クリック** してブループリントのイベント グラフで選択して利用できるということを覚えておいてください。戻り値または出力パラメータがあれば、 **[My Blueprints]** タブにリスト表示され、 **右クリック** して "implement" 関数を選択することでオーバーライドすることができます。 BlueprintImplementableEvents は関数のネイティブな実装を持たないことにご注意ください。 |
| **BlueprintNativeEvent** | 上記と同じです。ただし、この関数にはネイティブのデフォルト実装があり、ブループリントがその関数をオーバーライドしなければ呼び出されます。ブループリントがある種のデフォルトの挙動を実装しないが、必要に応じてブループリントがその機能をオーバーライドできるようにしたい場合に、ある種のデフォルト挙動を必要とするものに対してこれは有用です。これらは、コストがより多くかかるため、そうした機能が必要な場合に限り使用します。BlueprintNativeEvent をオーバーライドしても、必要に応じてネイティブ実装を呼び出すことができます。イベントまたは関数エントリを **右クリック** し、 [親関数に呼び出しを追加] を選択して行います。 |

