INTSourceChangelist:2406389
Availability:Public
Title:環境について賢く質問する
Crumbs:%ROOT%, Engine, Gameplay/AI, Engine/AI/EnvironmentQuerySystem
Description:AI プログラマーであるr Mieszko Zielinski がEnvironment Query System の前身である Environment Tactical Querying について書いた白書です。

[VAR:Topic]
[OBJECT:Topic]
	[PARAM:image]
		![%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%](AI_Topic.png)
	[/PARAM]
	[PARAM:icon]
		![](%ROOT%/start_icon.png)(convert:false)
	[/PARAM]
	[PARAM:title]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%
	[/PARAM]
	[PARAM:description]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:description%
	[/PARAM]
	[PARAM:path]
		[RELATIVE:Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions]
	[/PARAM]
[/OBJECT]
[/VAR]
[VAR:TopicCompact]
[OBJECT:TopicCompact]
	[PARAM:image]
		![%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%](AI_Topic.png)
	[/PARAM]
	[PARAM:icon]
		![](%ROOT%/start_icon.png)(convert:false)
	[/PARAM]
	[PARAM:title]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%
	[/PARAM]
	[PARAM:description]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:description%
	[/PARAM]
	[PARAM:path]
		[RELATIVE:Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions]
	[/PARAM]
[/OBJECT]
[/VAR]

[toc]

## はじめに

* このドキュメントは、AI プログラマーである Mieszko Zielinski が **Bulletstorm** での作業中に書いたもので、Environment Query System (**EQS**) の基礎を成すコンセプトが分かります。アンリアル エンジン 4 の Environment Query System (**EQS**) の前身である **Bulletstorm** の Environment Tactical Querying (**ETQ**) システムを参照しています。

## x.1 はじめに 

シューティング ゲームなど複雑で動的な環境の中で逃げ道を探すのは大変です。フレームを節約するための CPU Tick をほとんどもたない AI アクタであればなおさらです。生きていくのは大変だ。「どこへ行けばいいんだ？どっちがいいのか分かるような場所が沢山あったらああ！敵がいる！2 人だ！いや、3 人だ！誰を一番最初に撃つべきか？」

CPU 時間をかけずに、 AI が必要とする全てのデータすべてを、柔軟で使いやすい形で提供するサービスを作成するのは難しいタスクです。いろいろなものを探し、フィルタし、採点する能力が必要です。Bulletstorm 用に、CPU 時間がそれほどかからず、かつデザイナにとって直感的な、 AI の空間認識のニーズをすべて提供すシステムを作りました。システムに時間をかけさせてしまう、直感で分かりにくいデータを人間に作成させるのではなく、人間が簡単に理解できる入力を受け取るシステムの作成に集中しました。

## x.2 同期

Bulletstorm の開発初期に2 台のシステムが新規に作成され実装されました。 1 台は AI のロジックのためのシステム (ビヘイビアツリーの実装) で、もう 1 台は中央化された環境照会用のシステムです。この記事は Environment Tactical Querying (略して ETQ) と呼ばれる後者のシステムについてです。

Bulletstorm の環境照会は、対象のタイプおよびプロパティの 2 つのフォームを受け取ります。タイプは、「敵」、「カバー」「位置」などです。プロパティは、「navmesh 上」、「敵からは見えない」、「リーダーから少し離れている」などです。「見えない方がいい」や「自分に近い方がいい」といった、好みのフォームを受け取ることもできます。

## x.3 目標

システムの一生を通じて追うことのできる目標を幾つか設定しました。

* **"質問の仕方" ではなく "質問の内容" を考える** - 質問の作成と仕方は、できるだけシンプルにすべきです。自分達の創造性は、一切邪魔されたくないからです。
* **プログラマー以外の人に作業をさせる** - デザイナ専門のエディタを最初から作成することを目指しました。クリックするだけで、AI ピックカバーまたは敵の変更や調整をエディタ自身が思いのままにできるからです。
* **コードの再利用性** - このルールを徹底してコード化すると、コードはコンパクトで非常に整います。
* **パフォーマンス** - 他のシステムへのパフォーマンスに影響を与えることなく、このシステムが動作できることが必須です。
* **非同期性** - ETQ システムそのものはゲーム スレッド上で動作していたとしても、質問されることでゲームがすぐに回答を抽出するのを妨げないように非同期にしました。そうすることで、システムは実行されるクエリ処理を定期更新の間にスケジュールします。また、タイム スライスをメインのクエリ処理ループにすることも可能になります。

## x.4 指針

自分自身に簡単な問いかけをすることで、クエリをオーサーするようなデータ クリエータが理想でした。

* **何を生成すべきか？** - カバー、敵の位置、ポイントなど、ゲーム ワールド内に位置を持つもの全てが対象です。
* **誰からの質問か？** - クエリの Context オブジェクトは何か？ - どのエンティティが聞いているのかに関してです。AI アクタである場合がほとんどですが、AI が追跡中の敵 (彼はどこへ行けるのか？)、カバー、スポーン地点に関する質問の場合もあります。
* **どこを見るべきか？** - 候補アイテムの空間的な制限についての情報です。Context オブジェクトの周りの半径や、オブジェクトが割り当てられた戦闘ゾーンでアイテムを生成することができます。
* **どのアイテムが合格か** - 合格したアイテムの最低品質に関してです。幾つかの reference オブジェクトからアイテムが見えるように要求する場合もあります。
* **どちらのアイテムがいいか** - あるアイテムが別のアイテムより良いとする理由です。好みの理由は、あるものから近距離か遠距離か、あるプロパティがあるかないか、プロパティ値が設定限度より低いか、などです。

## x.5	アナトミー

ETQ システムはデータドリブンのソリューションで、大部分のパワーはデータが表されるようなデザインになっています。非常に慎重に検討して、かなり柔軟であり同時に効率的になるように配慮しました。では、デザインの詳細を見ていきましょう。 

### x.5.1	Query

Query には 3 つの主要なコンポーネントがあります。

* **Context オブジェクト** - 質問をしているゲーム エンティティ (厳密には、質問をしている人の代わり)?このクエリに対する空間的なコンテキストは何でしょうか？「あのスポットはここから見えるのか」とか「自分の視界内にあるのか」など、主観的なワールド ビューを定義するためにこのアクタのプロパティを使用するため、非常に重要です。Context オブジェクトは AI アクタでなくても構わない点に注目してください。 
* **QueryTemplateId** - 質問をしたユーザーのうち、どのユーザーに質問しているのか？システムで登録されたクエリ テンプレートには全てユニークな ID が付いており、この ID を元にどれを使うべきが分かるようになっています。
* **Items** - 検出されたアイテムが全て置かれるところで、次に行われるフィルタ テストに落ちたものは全て削除されます。

クエリ プロセスをトリガするために、どのクエリ テンプレートを実行すべきか、そのクエリの空間的なゲームプレイ コンテキストは何かに関する情報を提供する ETQ システムを呼び出します。バックグラウンド処理ではなく、すぐにクエリを処理するように要求することも可能です。

### x.5.2 クエリ テンプレート

ランタイム時に質問する方法は分かりました。では、質問はどのように定義するのでしょうか。検出対象は何か、興味のある「よいアイテム」が持っているプロパティは何かを表現する必要があります。要求しているプロパティ以外は、アイテムの採点のみに使用することもあります。

質問は、エディタ内で、我々が作成した特別なツールで定義し、通常のアセットとして保存されます。このアセットは Query Template としてコードで参照されます。Query Template は、1 つ以上の Option で構成されており、Option はいくつかの Test で構成されています。

まず、Query Template は、後のステップで処理されるアイテム エントリの生成方法に関する情報が含まれる Option を定義します。これにより、ゲーム ワールドにおいてエンティティを表現するアイテムのコレクションが作成されます。以下のような様々なジェネレータを実装しました。

* **Context Object's Enemies** - AI が気付いた全ての敵を集めます。
* **Covers** - 結果的に context オブジェクトのパラメータ化された半径内のカバー地点のコレクションとなります。
* **Points on grid** - オブジェクトの周りの設定可能なグリッド上にポイントを生成します。

ETQ は、新規のジェネレータのオーサリングを至極簡単にします。時には、2、3 行のコードしか必要としないこともあります。

Query Template の Option 用にジェネレータが設定されると、これらのアイテムのフィルタ方法および採点方法が指定されます。アイテムが "テスト" によって評価され採点されます。Pseudo (擬似) コードについては、リスト x1 の Test 構造体を参照してください。Test Structure は (TestType) 用のテストに対するプロパティ、テストのためのリファレンスのリスト (Reference)、比較タイプ (ConditionModifier)、(TestedValue) に対する比較値を指定します。テストを使って採点する場合、テストにウェイトを代入することもできます。

	struct Test
	{
		TestType;      	// Distance, Reachability,...
		ConditionModifier;  	// None, Min, Max
		Reference;     	// Self, Enemy, Leader, Item,...
		TestedValue;   	// float, int, bool, ... 
		SymbolicValue; 	// Melee distance, Weapon range,...
		Weight;   	// float in [-1,1]
		/** flags */
		bCondition;    	// boolean flag indicating this test is 
				// used as a condition
		bValidityTest; 	// and/or as a validity test (see x.5.3)
		bWeight;  		// or as a weight
	} 

_リスト x.1 Test structure 用の擬似コード_

テストの設定順序は関係ありません。テストは演算処理の負荷 (どれがどれより負荷が高いという相対的なリストでプログラマが評価します。詳細はセクション x.7 を参照) 、およびそれが条件なのかスコアリング テストなのかに応じて順序が変更されます。最も負荷の高いテストでさえ、採点を行う前に行います。こうすることで、採点中のアイテム数を減らすことができますが、長期的に見てこれが時間の短縮になるかどうかは議論の余地があります。この問題については、セクション x.10 の「最終テスト」で取り上げています。

テストに制限がありすぎて条件を満たすことができるアイテムがない場合は、クエリ全体を単純に失敗させるのではなく制約を緩めた方が良いかもしれません。このシナリオをシステムはサポートしています。Query template にオプションが 1 つ以上存在する場合は、1 つがクエリの結果となるアイテムを生み出すまで、オプションを全て順番に処理します。

### x.5.3 妥当性のテスト

Quesry Template のオプションに宣言されたテストが、条件、ウェイト、またはその両方となり得ます。ただし、ETQ で所定のテストを「validity test」と指定することもできます。これらのテストはカバー生成時には使用されませんが、その後、AI がそのカバーの方へ移動していたり、カバーに座った時にこのカバーの妥当性 (敵からの銃撃に曝されないなど) を確認するために使用されます。普通のテストと妥当性テストを両方一緒に行うことも、もちろん可能です。このように、カバー ポイントを選択する方法、および後にその妥当性を伝える方法に関する全てのコンフィギュレーション情報が見事に一箇所に収集されます。その 1 つの対象アイテム上でクエリを再実行すれば同じ機能を実現できますが、妥当性はそのまま実行しながら必要のないテストも多数実行されてしまいます。妥当性テストのためだけにウェイトの軽いクエリを別に作成することもできますが、どちらか一方が変更されたら必ず両方のクエリの同期を取ることが必要になります。いくつかのテストを妥当性テストと示しておくことが両方のワールドにとって最善です。必要なテストのみ実行している進行中のテスト中、同時にアイテムを選択し 1 つのクエリ アセットで進行中の妥当性に対するロジックをすべて維持しつつ、必要なテストのみ実行します。

### x.5.4 A ロールにおけるテスト
すべてのテストへのインターフェースがうまく統合されるように、Condition と Weight としての両方のロールですべてのテストが意味をなすようにしました。例えば、「敵までの距離」を条件をして使用する場合、それを 2000 単位未満あるいは 2000 単位以上となるように要求することができます。ただし、それをウェイトとして使用する場合、敵までの距離は近い方がいいのか、遠い方がいいのかという好みとして解釈します。テストのウェイト値を設定することで、テストされたプロパティに対する好みを表現します。値が高いほど、そのプロパティは好まれています。表 x.1 で例を紹介します。

| Test | Condition | Weight |
| --- | --- | --- | 
| Visibility | Is (not) visible | Prefer (not) visible |
| Distance | More/less/equal to X | Prefer closer/further away |
| Configurable dot | More/less/equal to X | Prefer more/less |
| Within action area | Is (not) in action area | Prefer (not) in action area |
| Reachable | Is (not) reachable with navigation | Prefer (not) reachable |
| Distance to wall | More/less/equal to X | Prefer more/less |
| Current Item | Is (not) current item | Prefer (not) current item |

_表 X.1 は、様々なテストが条件とウェイトの両方として利用されている例です_

## x.6 中心部

コアの ETQ アルゴリズムは、以下の擬似コードでキャプチャされます。

	foreach Option in QueryTemplate.Options:
		Query.Items = (generate items with QueryTemplate.Generator 
					   using contextual data from Query);
		if Query.Items is empty:
			continue to next option;
		foreach Test in Option.Tests:
			Reference = (find world object Test refers to);
			if Reference not empty or not required by Test:
				// this is explained in section X.7 under "Fail Quickly"
				if Test has a fixed result:	
					apply result to all Query.Item elements;
				else:
					perform Test on all Query.Item elements;
				if Test.bCondition is true:
					filter out all Query.Item elements that failed Test;
				if Test.bWeight is true:
					foreach Item in Query.Item:
						calculate weights from every test result
		if Query.Items not empty:
			foreach Item in Query.Item:
				sum up all weights calculated by weighting tests;
			sort Query.Items descending with computed weight;
			return success;
	return failure;
	_Listing x.2 The core ETQ query algorithm_


## x.7 実装の詳細

アルゴリズムは、最も簡単なものでさえ、実行中に何かしらのトリックがいつもあります。このケースでは以下が行われました。

* **Start with cheaper tests** � 期待されたパフォーマンスに応じて、テストタイプを実行前にソートしました。例えば、Distance テストの負荷は、アクタにタグが付いているかをチェックするよりも大きくなりますが、ポイントがナビメッシュ上にあるかどうかを調べるよりも小さいです。 
* **Fail quickly** - クエリのコンテキストの広さによって、全てのアイテムで結果が同じにできるテストもあります。例えば、ポイントがナビメッシュ上にあるかどうかの確認は、ナビメッシュ上になければ必ず失敗します。分隊のリーダーや敵など、所定のコンテキストに存在しないリファレンスを要求すると、即失敗することがあります。
* **Normalize test results and weights** - 距離テストを「プロパティの有無」の類のテストに対してウェイトしても不可能だということがすぐに分かります。既知の最大距離と使ったとしても、最大値を変更した途端に失敗し、再調整を求められます。従って、すべてのテストの結果をノーマライズすることに決めました。テストの実行中、結果の最大値を格納し、テストが終了した時点でその格納したすべての結果の最大値をノーマライズします。処理されたオプションのアイテム生成範囲を使用するケースもあります。ウェイトは常に (エディタ経由で) `[-1,1]` 内になるようしています。結果をノーマライズすると共に好ましい数学的なプロパティが与えられ、信頼できるクエリ調整ができます。
* **Debug-draw whatever you can** - デバッグ ドロー機能のオーデバッグバーホールはできません。このようなシステムの開発中には、ランタイム中に選択したターゲット上でクエリをトリガーできることが極めて重要です。そして結果を見る必要があります。結果をデバックドローするだけでクエリ内に幾度となくバグを発見でき、それによりかなりの時間を節約できます。

## x.8 エディター

アンリアル エンジン 3 によるツール作成の手軽さを活かして、ETQ 用のツールを作成しました。クエリ アセットと機能するように作られたツールを使うとさらに快適で、直接的な結果としては、さらにクエリと機能し、調整し、間違った設定がされているとすぐに分かるようにしたくなりました。図 x.1 は、エディタ内の Query Template です。

さらにツールには次のような機能が備わっています。

* **Weights auto-scaling** - テストのウェイトが [-1,1] の範囲に変更されると、エディタは所定のクエリ オプション内の全てのウェイトが実装セクションで記載されている範囲におさまるように、再度スケールします。
* **Auto-arranging visuals** � クエリは木のような構造体で表されます。テストをビジュアル化するために使用した全てのエレメントは、ヘッドとしてオプション ノードを持つカラムに置かれました。これにより、他の人によりクエリの中から回答を見つけやすくなります。
* **Descriptive labels** - クエリ アセット内の全てのノードを、プログラマ以外でも分かるような、それ自体を説明する文字列にして、エディタ内でのビジュアル化上でそれを表示しました。例えば、「Leader has a straight line path to」 (条件) 、または「Distance to context object, prefer less」 (ウェイト) などのラベルをつけました。経験の浅い人であっても、あるクエリを見ただけで、それが何を生成するのかをある程度理解できるようにするためです。 
* **Coloring** - これは分かりやすいと思います。設定が間違っていたり、値が抜けているものは全て黄色で色をつけました (それ以外のものは逆に暗い色です)。これにより、クエリが壊れた場所が一目で分かります。

## x.9 長所と短所

ETQ では便利なプロパティがいろいろ実現されています。幾つか紹介します。

* **Intuitive query creation** - 作成したツールを使うと、デザイナーでさえもクエリの作成が可能になり、最低限のチュートリアルで済みます。このような類のクエリなら、技術よりではないデザイナも全く問題なく理解できると考えに近づけました。
* **Data driven** - コードが機能するまさにその方法でデータを制御することは、ゲーム開発の聖杯とも言えることです。例えば、AI が敵やカバーを選択する方法を変更しても、プログラマは都度関わる必要がなくなりました。
* **Efficient** - システムをタイムスライスし、クエリがありえない数のアイテムを生成しないように設定すれば、非常に洗練されたクエリで指定されたプロパティのゲーム エンティティを探しながら、ETQ を平均 0.02 ms/フレーム 以下に圧縮することができます。
* **Flexible** - テストまたはジェネレータの新規追加は非常に簡単です。現在のテストやジェネレータには備わっていないものを追加しなければならない場合、誰でも簡単に追加することができますし、(タイムスライスしてあるので) ランタイム時でも効果的です。

ETQ の一番の問題は、クエリの調整して希望するクエリを生成するまでに時間と経験が必要なことです。一方で、クエリでの作業中のイタレーションは非常に速く (イタレーション用のランタイム ツールもあります)、経験の浅いユーザーでも必要な直感を非常に早くつかむことができました。

「Gears of War:Judgment」でも ETQ システムを使いました。いくつかタスクを適用すると、問題がいろいろ表れました。大きな問題の 1 つは、CPU の使用量が 15ms まで急増したケースが見られました。各テストをタイムスライスせずに、1 つのアイテム コレクションとして自動的に処理しているので、大きなアイテム コレクション上で負荷の高いテストを実行したことが原因です。急増の原因は、クエリ ジェネレータがレベルにおかれたエンティティからカバーを収集した範囲 (ここでは「Goal Actors」) 、つまりレベル デザイナが設定した値を読み取ったためです。実はこの問題はデータ ドリブン システム固有の問題です。デザイナがデータを与えたことで、システムのパフォーマンスが台無しならないように注意が必要です。緊急措置は、経験に基く最大値で半径を制限することです。 

## x.10 修正点と改善点

Bulletstorm の出荷の最終段階に辿りつくために、いろいろな改善点が沢山ありました。以下になります。

* **Merging tests** - いくつかのテストで、カバー ポイントに対して、「敵までの dot product が X 以上」で「敵までの距離が Y 以上」で「現在のカバーではない」といったようなグループとして表す傾向にあります。直感的には、3 つのテストを順番に実行するよりも、全部を実行する特別なテストを 1 つ作った方が合理的に感じます。
* **Final test** � フィルター数を増やしても、テスト対象のアイテム数は減らすことができない場合が多いです。負荷の高いテストを行わなければならない場合、処理するプロセス数が多すぎて、パフォーマンスが悪くなります。「最終テスト」というアイデアは、そのテストを最初にパスする必要のあるアイテムを N 個選択し、残りのアイテムのテストを中止します。最終テストは処理の一番最後なので、全てのアイテムに対して負荷の高いテストを実施しなくても十分な結果を得ることができます。
* **Reversed processing** - [Robert 11] が 現在 AI が使用しているカバーを素早く選択するスキームよりも良いスキームを紹介しました。同じスキームが ETQ に追加されます。クエリの通常処理を実行する代わりに、AI の現在のカバーポイントを受け取り、まずそれを採点し、クエリのフィルタの全てをパスし、高得点を持つ一番最初のアイテムとして認めます。
* **Multi-generators** - Query Template が複数のジェネレータを使えるようにします。異なるアイテムのコレクション上で統一されたテストを実行できるように (1 つのパスで通常のポイントとカバー ポイントのように)。
* **Multithreaded implementation** - 別のスレッドで ETQ を実行する必要も CPU リソースもありませんが、プログラムにより多くの CPU を与える傾向があるので、今後期待できる方向です。

## x.11 まとめ

説明したシステムは、設計的には非常にシンプルであるにも関わらず、とてもパワフルなことが分かっています。CPU 時間をそれほど消費せずに、大きなパワーで環境照会ができます。ETQ を専用のオーサリング ツールで作成したデータとクエリでドリブンされるようにすると、AI の敵とカバーの選択に対するイタレーションを非常に早くすることができます。ランタイム デバッグ ツールでさらに向上します。
概要レベルでも良い点があります。一番最初から ETQ を非同期サービスを条件として考えていたので、その他の AI システム コンポーネントも同様に非同期にしやすくなりました。非同期の AI を設計および実装することは「旧い方法」とは若干異なる考え方をしますが、複数のコアでうまくスケールし、この先ずっと必要条件となるソリューションになりました。

## x.12 謝辞

本書の執筆中、語りかけてくれた妻の Agata に感謝いたします。Bulletstorm AI に対するアイデアを思いつかせてくれた Lukasz Furman にも感謝いたします。

## x.13 文献 

\[Robert 11\] Gabriel Robert "Cover Selection Optimizations in GHOST RECON" Paris AI Conference Shooter Symposium 2011

## x.14 論文抄録

本文は、カバー ポイント、敵、その他の敵の種類を柔軟かつ効率的に照会する Bulletstorm 用に実装したシステムに関する記述です。領域内のカバーの一覧はどのように作成するのか？なぜ AI アクタに対して、それが一番良いといえるのか？本書は、クエリ システムである ETQ と、直感的かつ柔軟的な方法でクエリを指定する方法の説明です。使用しているアルゴリズムの概要も含まれています。実装上のトリックだけでなく、今後の改善にむけた方向性も記載しています。 

## x.15 著者について 

Mieszko Zielinski

People Can Fly の Senior AI Programmer である Mieszko Zielinski は十年近くゲーム開発に携わってきました。2003 年にゲーム業界に興味を持ち、Aidem Media という小さなスタジオに入社して、最初の一歩を踏み出しました。以来、 Zielinski は CD Projekt Red 、Crytek 、そして素晴らしいプログラマ チームと共に白紙の状態から "Bulletstorm" 用に AI システムを開発した People Can Fly に勤務してきました。現在は、Epic Games 社のアンリアル エンジン 4 向けの AI システム エレメントを開発中です。

因みに彼は、ポーランド国籍のキックボクシング チャンピオンです。彼を怒らせないようにしましょう ;)
