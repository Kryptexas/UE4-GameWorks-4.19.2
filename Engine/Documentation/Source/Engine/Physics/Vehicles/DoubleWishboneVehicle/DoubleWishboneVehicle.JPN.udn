INTSourceChangelist:2322656
Availability:Public
Title:ダブルウィッシュボーン式サスペンション ビークルのビルド方法
Crumbs: %ROOT%, Engine, Engine/Physics
Description:
Navigation:topic

[TOC (start:2)]

## はじめに

本プロジェクトおよびチュートリアルはコミュニティ メンバーである Xenome による提供であり、承諾の元に掲載しております。

Xenome の皆様に感謝いたします。

## 概要

このチュートリアルでは、高度なビークル テンプレートの詳細を紹介します。チュートリアルを完了する頃には、理論的な仕組みや、似たようなものを自分でビルドおよび設定する方法について、かなり理解できるようになっているはずです。チュートリアルはサスペンションを中心に進めていきます。

ビークル テンプレートで使用しているすべての FBX アセットは [こちら](DoubleWishboneVehicle_Files.zip) からダウンロードできます。FBX ファイルの読み書きが可能なモデリング パッケージであれば、オリジナルと体験版を自分のデザインで分析することができるはずです。

始める前にお伝えしておきたいのですが、ダブルウィッシュボーン式サスペンション ビークルは標準のアンリアル エンジン 4 のビークルに比べて、かなり複雑な設定になっています。これまでに完了できなかった設定がある場合は、そちらを完了することを強くお勧めします。Epic は YouTube で標準的な手順を大変わかりやすいビデオでご紹介しています。[リンクはこちら](https://wiki.unrealengine.com/Introduction_to_Vehicles_in_UE4_Playlist)

このビデオをみて基本となるビークルの設定が無事完了したら、本ページで取り扱うダブルウィッシュボーン式サスペンション ビークルを始める準備ができました。基本的な理論から始めましょう。

## シュミレートされた車輪と本物のサスペンションのリンケージ

ビークル移動コンポーネントを設定し、それに車輪を割り当てると、車輪の垂直の移動がビークルの Animation ブループリント内の **WheelHandler** ノードで通常は更新されます。それぞれのフレーム上で、ハンドラがローカルの Z 軸に沿って上下にホイールを移動させてサスペンションのシミュレーションを行い、可能な限り車輪がグラウンドに触れることを確かめます。

さらに **WheelHandler** は、シュミレーションしたモーターとギアボックスの回転速度で車輪が Y 軸周りでスピンするように回転も適用します。この他に、現在のステアリングを操作し、車輪を Z 軸の周りで回転させます。

デフォルトの垂直なサスペンションの移動は、 VehicleWheel で操作されるクラス内の [Suspension Max Raise and Drop] 設定でクランプされます。この移動は、以下のように、完全に線形です。

![](simwheeldefaultmovement.gif)(convert:false)

_**WheelHandler** によって作成される標準的な垂直の移動_

完全にリアルにはならないものの、サスペンション アームまたはスプリングやショックなどの他のコンポーネントを通常は見ることはできないので、このタイプのサスペンションのシミュレーションは実はほとんどのビークルに適しています。車のボディ全体のモデルであれば、通常はうまく処理できます。

ただし、移動部品がむき出しになっているバギーやフォーミュラー 1 カーなどのオープン型のビークルの場合、この移動が問題になります。なぜなら、このタイプの移動を生み出す実用的なサスペンション設計が現実の世界には存在しないからです。

結果をさらに現実的にするためには、ビークルのボディに固定された回転軸周りの回転として表現することのできるタイプのモーションが必要です。

![](realwheelmovement.gif)(convert:false)

_理想的な垂直および横方向の移動_

この難題を解決するために、まずはホイール管理を次の 2 種類に想定しましょう。 1 つは **WheelHandler** ノードが制御するシミュレーションした Wheel ノードで、もう 1 つは、車を運転する時に実際のレンダリングを見ることができる車輪です。その後で、希望する結果を出すために **WheelHandler** によって我々に提供したデータを残りのサスペンション設定へ送ることができます。

つまり、表示される車輪とシミュレーションした車輪は実は全く別の 2 つオブジェクトで、シミュレーションした車輪は全く表示しなくてもよいのです。

VehicleWheel クラスで定義した Wheel パラメータは、コリジョン メッシュ、半径と幅と明示的に指定することができます。これらの指定は、ビークルのスケルタル メッシュ内のリアルなジオメトリと必ず一致させる必要はありません。従って、リアルなジオメトリを適用するためにメッシュ内でシミュレートされた車輪のノードは全く必要さらに、ビークルのブループリントの車輪設定セクションで、車輪のオフセットを追加できます。従って、車輪の回転軸を表示されている車輪メッシュのジオメトリの中心とそろえる必要はありません。

メカニカルな視点から本当に動くようなサスペンションをビルドする必要があるというのが、基本的な見解です。

## Skeletal ノードの機能

さてここで、設定時に特に便利な 2 つの Animation ブループリントノードについて説明しなければなりません。さきほど説明した **WheelHandler** ノードは絶対に使うのですが、このタイプのリギングに非常に重要で強力なツールがあと 2 つあります。それは **CopyBone** と **LookAt** ノードです。両方ともアニメーション ブループリントの Skeletal Control カテゴリに存在し、標準位置、回転、エイム コンストレイントは基本的に Maya のようなアプリケーションで実行されるので、 2 つともほぼ同じタスクを実行します。

### ボーンをコピー

名前の通り、 **CopyBone** ノードは、あるボーン (ソース) の変形データを別のボーン (ターゲット) にコピーすることができます。

![](node_copybone.png)

_**CopyBone** animation Blueprint ノードおよびデフォルト設定_

つまり、 **WheelHandler** がシミュレーションした車輪の変形情報を更新すると、例えば作成された回転値のみを取得し、表示中の車輪に適用することができます。この基本的なステップでは、是非とも使いたい車輪のスピンとステアリングを処理し、必要ではない平行移動 (位置) データを取得しないようにします。

### Look At

**LookAt** ノードは、基本軸の 1 つが別のボーンを向いて終わるように、任意のボーンを回転させます。

![](node_lookat.png)

_**LookAt** animation Blueprint ノードとデフォルト設定_

シミュレーションした車輪の現在位置で、直接または間接操作されるサスペンション メカニズムのすべてのコンポーネントが正しい方向のポイントへ常に更新されていることを確認できるので、設定の際に便利です。**LookAt** ノードを使って向きを調節できるボーンがあるかどうかを確認すればいいだけです。アニメーション ブループリントでこれを使用するボーンもあります。

## 実装概要

4 つの車輪のそれぞれを再キャプチャするためには、 **WheelHandler** に対して非表示の車輪を 1 つ使って管理し、表示中の車輪の 1 つをゲームで実際にレンダリングします。最初の例は、メッシュのウェイト付けがない単一のボーン / ジョイントで、後の例はモデリング パッケージでビルドしビークル モデルに追加した車輪のようなメッシュで、 UE4 の最終的な設定にインポートされます。

目的どおりにすべてを機能させるために、サスペンションの主要なパーツが必要な変形データを他のボーンからコピーするか、モデルで設定したターゲットを見る方向を調整します。

## モデルを作成する

理論はさておき、このデモの中のビークルがどのように作成されたかを見ていきましょう。メインのモデリング アプリケーションで Assets/FBX/vehicle_proto_S2.9.fbx を開くと、すべてがどのようにはめこまれていくのか追うことができます。

このチュートリアル用に作成したビークルには、このように設計されたサスペンション リグがあります。

![](keycomponents.png)

_プロトタイプ ビークルのフロントの右側のサスペンションを拡大してみます。この図例では分かりやすいように色をつけてありますが、 FBX ファイルのマテリアルには色は割り当てられません。_

ここでキーとなるコンポーネントは、上腕と前腕 (黄色) 、キングピン (赤) 、ハブ (青) です。それぞれの六角ボルトの周りの両腕の軸は、画像のかなり右に表示されています。

すべてが集まる真ん中のポイントは、ロワアーム上の緑のボルトに近いです。ここに、シミュレーションしたジョイントである `PhysWheel_[loc]` をまず置きます。キングピン、ハブ、表示中の車輪にも、全く同じ位置に軸があります。

これらの各コンポーネントには、非常に厳格な責任と変換範囲があります。アームは Forward 軸周りの回転のみです。キングピンはロワアームの先端位置を追いますが、終始垂直に保たれ、ビークルにつられて動くことはありません。ハブは、ステアリングに反応して、垂直軸周りの回転のみです。表示中の車輪はシミュレーションした車輪から回転をコピーしますが、ロワアームの先端からその位置を受け取ります。こうすると、全部まとめてしっかりロックされた状態を保ちます。

かなり複雑なリグでは、階層を保ち順序を更新することがとても大切になることを覚えておいてください。このケースは特殊で、ロワアームが回転すると、キングピンは **CopyBone** ノードを使って自分で正しく配置するために、その後で必要な子メッシュ (下側の緑のボルト) で呼び出さなければなりません。その代わり、 **LookAt** ノードなどを使用するために、キングピンの子メッシ (上側の緑のボルト) の更新された位置にアクセスする必要があります。お分かりのように、異なるコンポーネントが正しい順番で更新されていることを確認するのは必須です。そうでないと、サスペンションの部品が他の部品の移動より遅れて見えてしまう場合があります。

このようなフレームごとの更新はすべて Animation ブループリントで処理されます。

DCC (Digital Content Creation) アプリケーションでモデルをビルドする時は、コンポーネントの軸の階層と正確な位置と方向だけを注意していればいいのです。**LookAt** ノードで更新された回転を持つコンポーネントの場合は、方向に気をつけることはとりわけ重要です。

一般的な注釈として、この種類のメカニズムを作成する間は、お持ちのモデリング パッケージで提供されているコンストレイントを使うと便利です。それらはインポート時に UE4 へ FBX をフォローしませんが、モデルのビルド中に基本的な移動をいくつか取得する場合にすべきことの計算が楽になります。異なるコンポーネントが交差することなく必要な方法での移動を可能にするために、ただし、 Animation ブループリント内で再度作成することができないコンストレイントの使用は避けてください。

## アンリアル エンジン 4 の設定

このデモがアンリアル エンジンでどのように設定されたかを見てみましょう。エディタにプロジェクト ファイルをアップし、ビークルの Animation ブループリントを開きます。ほとんどの操作は、車輪ごとに 1 回ずつ、計 4 回適用されることにご注意ください。

ビークルの操作中、 Animation ブループリントでは次のことが起こります。

まず、 **WheelHandler** がシミュレーション中の車輪 (「PhysWheel」のボーン) を更新します。それから、表示中の車輪 (「VisWheel」のボーン) が PhysWheel から回転をコピーして、回転を更新します。

![](animBP_1.png)

_表示中の車輪への Copy Rotation に続いて **WheelHandler**_

これにより、スピンとステアリングが視覚的に正しくなりますが、車輪の位置は変わりません。これは後で別途説明します。

次に、ロワ アーム (「ArmLower」のボーン) は「PhysWheel」の位置の方へ向きます。ビークルの右側のアームは look at axis として Y を使用し、左側のアームは Negative Y を使用します。

![](animBP_2.png)

__PhysWheel の位置を見る ArmLower ボーン_

**LookAt** ノードの結果は Animation ブループリント エディタの 3D ウィンドウで簡単にプレビューできます。選択された **LookAt** ノードの現在のターゲットが赤い十字でマークされます。プレビュー ビューポートをワイヤーフレーム モードに設定すると、簡単に表示できます。

`ArmLower` ボーンが回転して **LookAt** ターゲットと一致すると、`POS_Hub` と呼ばれる子のコンポーネントも付いてきます。次のステップではこれを使って `POS_Hub` ボーンの平行移動のみを取得する **CopyBone** ノードを使ってキングピンを正しく配置します。

![](animBP_3.png)

_キングピンの位置設定_

Hub と VisWheel は同じ方法で同じ位置に後で設定します。

次のステップでは、これらがキングピン ボーンの子供であるという事実により正しい位置に配置されている各ターゲットを見て、前のステップで更新されたアッパーアーム (`ArmUpper` ボーン) を調整します。

![](animBP_4.png)

_アッパーアームを方向づける_

ハブの位置の設定後、フロントのハブだけはステアリングに起因する Z 軸周りの回転を起こすために、まだ作業が必要です。フロントの PhysWheels の子供である`LAT_Hub` ボーンの方を向いた **LookAt** ノードで処理されます。

![](animBP_5.png)

_ハブの位置とステアリング角度を設定する_

最後に、 VisWheel の位置が `POS_Hub` と一致するように設定したら、ショックの上部がロアショックマウント (`ShockMount_Low`) の方を向いていて、ロアショック ボーンはまさに同じショックマウントの位置になっていることを確認します。

![](animBP_6.png)

_表示中の車輪の配置とショック コンポーネントの調整_

##PhAT

プロトタイプの物理アセットの設定は、若干の例外を除けば、標準のビークル テンプレートとほぼ同じです。アンテナに沿って多数存在する小さな球体のボディが大きな違いですが、メインとなるビークル フレームの周りに存在するカスタム仕様のコリジョン形状の方がより重要です。

![](phat_1.png)

_PhAT コリジョン ボディ_

このモデルのルート コンポーネントは実際はジョイントなので、細かいコリジョン ボリュームの作成のために使用できるジオメトリはありません。メインとなるボディ ボリュームは、 UCX メッシュ (Assets/FBX/vehicle_collision_S2.9.fbx) のある別のスタティックメッシュをインポートして作成されました。

![](phat_2.png)

_別途インポートされたコリジョンのあるスタティックメッシュ_

これについては、 PhAT 内では全く対処できません。最初のステップは、選択した 3D モデリング パッケージでコリジョン アセットをビルドします。できれば、メインとなるボディメッシュから開始することが望ましいです。このコリジョン モデルはその後、標準メッシュとして UCX と一緒に UE4 へンポートされます。1 度これを行えば、 PhAT 内のビークルのルートノードへこのコリジョン データを簡単にコピーできます。このオプションを使用するには、 PhAT の階層パネルに存在するボディを右クリックします。ターゲットのボーンにまだボディが割り当てられていない場合は、カプセルなどを追加して使用します。カスタム仕様のコリジョンが追加されたら、カプセルは削除します。

![](phat_3.png)

_メニューの一番下の [Adcanced] にあるコリジョン オプションをコピーします。_

### アンテナの設定

アンテナはダブルウィッシュボーン サスペンションの部品ではないですが、ビークルの処理全般に影響します。
完全に固定されたアンテナは物理の影響を受けず、もちろん一番簡単な方法ですが、
このテンプレートでは、操作してもビークルの移動に悪いの影響を与えずに移動するアンテナの設定方法を説明します。

このテンプレートでは、最初の **Antenna1** から先端にある最後の **Antenna10** までのそれぞれのアンテナのボーンは、 
アンテナのメッシュそのものの半径とほぼ一致するような半径を持っている球体ボディで設定されています。このボディの **Enable Gravity** をオフにして、アンテナが物理システムからの最小の負荷で直立できることを確認します。 
これらのボディの質量は、 16 に設定された一番下の最初の質量のスケールから開始して、最後に近づくにつれて急激に減衰します。ボディの質量のスケールを前のボディの 50 `%` に設定するようにし、一番下から先端に向かって値が 16、8、4、2、1、0.5、0.25、0.12、0.06、0.03 となるようにします。 
これで、基盤は重たく、先端は軽く設定され、この 2 点の間にはスムーズなグラディエントが作成されました。 


![](phat_antenna_1.png)

これらのボディに適用されるコンストレイントは、線的にも角度的にも完全にロックされます。ボーン チェーンがかなり長いので、加速に反応して方向が若干変わります。上記の質量のスケールと組み合わせることで、シミュレーションが安定します。 
ほどよく楽しいオシレーションを使って、安定したシミュレーションが可能になります。

過度の加速中にシミュレーションが爆発することがないように、角度許容値を 1.0 にしてすべてのアンテナのコンストレイントでプロジェクションを有効にしておくと、 
ボディの Position Solver Iteration Count が 16 まで上昇します。

![](phat_antenna_2.png)

最後に、アンテナのボディおよびビークルの残りのボディ間での内部的なコリジョンはすべて、不要な内部の衝突を防ぐために無効にされています。これを簡単に行うためには、
 階層パネルのボディを持つボーンをすべて選択し、メインの PhAT ツールバーの **[Collision Off]** ボタンをクリックします。

![](phat_antenna_3.png)

## 実際にモデルをビルドする

設定方法が理解できたので、今度はこのプロトタイプに変えて自分のモデルを当然ビルドしたくなると思います。少しでも頭痛を減らすために、以下のポイントをお役だてください。

まずは、名前と階層をプロトタイプと極力同じにしておきます。こうしておくと、 Animation ブループリントを何も変更しなくても異なるスケルタルメッシュに再度割り当てたり、再利用することができます。時間の節約になります。もちろん、メッシュはすべて再モデル化できますし、異なる位置への移動も可能です。すべて正しく調整されていることだけを確認してください。サスペンションの主要なコンポーネントの階層全体の妨げにならない限り、モデルにメッシュ ノードを追加しても問題にはなりません。

ビークルのルートはグローバル空間の 0 、0 、0 に配置し、一切回転してはいけません。ルートを単純なジョイント オブジェクトにすると、特に、ショック メッシュの変形などのゆるく結合されたコンポーネントを使用する場合、 FBX のエクスポートとインポート時の問題発生を最小限にすることができます。

Z を Up 軸として使用する設定が可能なモデリング パッケージの場合は、そのようにしてください。いずれにせよ、例え選択したアプリケーションが Y を Forward 軸と判断した場合でも、 X を Forward 軸だと想定します。

モデリング アプリケーションで車輪のメッシュはフロア / グリッドに触れるはずです。モデルのコンポーネントのそれぞれに、目的とする回転の中心に回転軸があり回転がゼロ設定になっていることを常に確認してください。ただし、ショックは明らかに例外で、これはルート ジョイントと先端のジョイントがお互い向き合った方向にすべきです。操作に確信が持てない場合は、変形や同等の関数がフリーズしないように、 1、1、1 のスケールは決して使わないようにしてください。

## インポートのオプション

プロトタイプに使用した以下のインポート設定は、自分でカスタム化したモデルをインポートする場合の適切なガイドラインとなります。

![](import_options.png)

_プロトタイプのビークルに使用したインポート オプション_

... 高度なビークルのビルド方法について、かなり理解が深まったはずです。それでは皆さん、がんばってください！